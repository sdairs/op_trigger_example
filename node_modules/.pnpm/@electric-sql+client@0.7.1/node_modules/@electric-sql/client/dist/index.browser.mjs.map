{"version":3,"sources":["../src/parser.ts","../src/helpers.ts","../src/error.ts","../src/constants.ts","../src/fetch.ts","../src/client.ts","../src/shape.ts"],"sourcesContent":["import { ColumnInfo, GetExtensions, Message, Row, Schema, Value } from './types'\n\ntype NullToken = null | `NULL`\ntype Token = Exclude<string, NullToken>\ntype NullableToken = Token | NullToken\nexport type ParseFunction<Extensions = never> = (\n  value: Token,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\ntype NullableParseFunction<Extensions = never> = (\n  value: NullableToken,\n  additionalInfo?: Omit<ColumnInfo, `type` | `dims`>\n) => Value<Extensions>\n/**\n * @typeParam Extensions - Additional types that can be parsed by this parser beyond the standard SQL types.\n *                         Defaults to no additional types.\n */\nexport type Parser<Extensions = never> = {\n  [key: string]: ParseFunction<Extensions>\n}\n\nconst parseNumber = (value: string) => Number(value)\nconst parseBool = (value: string) => value === `true` || value === `t`\nconst parseBigInt = (value: string) => BigInt(value)\nconst parseJson = (value: string) => JSON.parse(value)\nconst identityParser: ParseFunction = (v: string) => v\n\nexport const defaultParser: Parser = {\n  int2: parseNumber,\n  int4: parseNumber,\n  int8: parseBigInt,\n  bool: parseBool,\n  float4: parseNumber,\n  float8: parseNumber,\n  json: parseJson,\n  jsonb: parseJson,\n}\n\n// Taken from: https://github.com/electric-sql/pglite/blob/main/packages/pglite/src/types.ts#L233-L279\nexport function pgArrayParser<Extensions>(\n  value: Token,\n  parser?: ParseFunction<Extensions>\n): Value<Extensions> {\n  let i = 0\n  let char = null\n  let str = ``\n  let quoted = false\n  let last = 0\n  let p: string | undefined = undefined\n\n  function loop(x: string): Array<Value<Extensions>> {\n    const xs = []\n    for (; i < x.length; i++) {\n      char = x[i]\n      if (quoted) {\n        if (char === `\\\\`) {\n          str += x[++i]\n        } else if (char === `\"`) {\n          xs.push(parser ? parser(str) : str)\n          str = ``\n          quoted = x[i + 1] === `\"`\n          last = i + 2\n        } else {\n          str += char\n        }\n      } else if (char === `\"`) {\n        quoted = true\n      } else if (char === `{`) {\n        last = ++i\n        xs.push(loop(x))\n      } else if (char === `}`) {\n        quoted = false\n        last < i &&\n          xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i))\n        last = i + 1\n        break\n      } else if (char === `,` && p !== `}` && p !== `\"`) {\n        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i))\n        last = i + 1\n      }\n      p = char\n    }\n    last < i &&\n      xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1))\n    return xs\n  }\n\n  return loop(value)[0]\n}\n\nexport class MessageParser<T extends Row<unknown>> {\n  private parser: Parser<GetExtensions<T>>\n  constructor(parser?: Parser<GetExtensions<T>>) {\n    // Merge the provided parser with the default parser\n    // to use the provided parser whenever defined\n    // and otherwise fall back to the default parser\n    this.parser = { ...defaultParser, ...parser }\n  }\n\n  parse(messages: string, schema: Schema): Message<T>[] {\n    return JSON.parse(messages, (key, value) => {\n      // typeof value === `object` && value !== null\n      // is needed because there could be a column named `value`\n      // and the value associated to that column will be a string or null.\n      // But `typeof null === 'object'` so we need to make an explicit check.\n      if (key === `value` && typeof value === `object` && value !== null) {\n        // Parse the row values\n        const row = value as Record<string, Value<GetExtensions<T>>>\n        Object.keys(row).forEach((key) => {\n          row[key] = this.parseRow(key, row[key] as NullableToken, schema)\n        })\n      }\n      return value\n    }) as Message<T>[]\n  }\n\n  // Parses the message values using the provided parser based on the schema information\n  private parseRow(\n    key: string,\n    value: NullableToken,\n    schema: Schema\n  ): Value<GetExtensions<T>> {\n    const columnInfo = schema[key]\n    if (!columnInfo) {\n      // We don't have information about the value\n      // so we just return it\n      return value\n    }\n\n    // Copy the object but don't include `dimensions` and `type`\n    const { type: typ, dims: dimensions, ...additionalInfo } = columnInfo\n\n    // Pick the right parser for the type\n    // and support parsing null values if needed\n    // if no parser is provided for the given type, just return the value as is\n    const typeParser = this.parser[typ] ?? identityParser\n    const parser = makeNullableParser(typeParser, columnInfo, key)\n\n    if (dimensions && dimensions > 0) {\n      // It's an array\n      const nullablePgArrayParser = makeNullableParser(\n        (value, _) => pgArrayParser(value, parser),\n        columnInfo,\n        key\n      )\n      return nullablePgArrayParser(value)\n    }\n\n    return parser(value, additionalInfo)\n  }\n}\n\nfunction makeNullableParser<Extensions>(\n  parser: ParseFunction<Extensions>,\n  columnInfo: ColumnInfo,\n  columnName?: string\n): NullableParseFunction<Extensions> {\n  const isNullable = !(columnInfo.not_null ?? false)\n  // The sync service contains `null` value for a column whose value is NULL\n  // but if the column value is an array that contains a NULL value\n  // then it will be included in the array string as `NULL`, e.g.: `\"{1,NULL,3}\"`\n  return (value: NullableToken) => {\n    if (isPgNull(value)) {\n      if (!isNullable) {\n        throw new Error(`Column ${columnName ?? `unknown`} is not nullable`)\n      }\n      return null\n    }\n    return parser(value, columnInfo)\n  }\n}\n\nfunction isPgNull(value: NullableToken): value is NullToken {\n  return value === null || value === `NULL`\n}\n","import { ChangeMessage, ControlMessage, Message, Row } from './types'\n\n/**\n * Type guard for checking {@link Message} is {@link ChangeMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ChangeMessage}\n *\n * @example\n * ```ts\n * if (isChangeMessage(message)) {\n *   const msgChng: ChangeMessage = message // Ok\n *   const msgCtrl: ControlMessage = message // Err, type mismatch\n * }\n * ```\n */\nexport function isChangeMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ChangeMessage<T> {\n  return `key` in message\n}\n\n/**\n * Type guard for checking {@link Message} is {@link ControlMessage}.\n *\n * See [TS docs](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)\n * for information on how to use type guards.\n *\n * @param message - the message to check\n * @returns true if the message is a {@link ControlMessage}\n *\n *  * @example\n * ```ts\n * if (isControlMessage(message)) {\n *   const msgChng: ChangeMessage = message // Err, type mismatch\n *   const msgCtrl: ControlMessage = message // Ok\n * }\n * ```\n */\nexport function isControlMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage {\n  return !isChangeMessage(message)\n}\n\nexport function isUpToDateMessage<T extends Row<unknown> = Row>(\n  message: Message<T>\n): message is ControlMessage & { up_to_date: true } {\n  return isControlMessage(message) && message.headers.control === `up-to-date`\n}\n","export class FetchError extends Error {\n  status: number\n  text?: string\n  json?: object\n  headers: Record<string, string>\n\n  constructor(\n    status: number,\n    text: string | undefined,\n    json: object | undefined,\n    headers: Record<string, string>,\n    public url: string,\n    message?: string\n  ) {\n    super(\n      message ||\n        `HTTP Error ${status} at ${url}: ${text ?? JSON.stringify(json)}`\n    )\n    this.name = `FetchError`\n    this.status = status\n    this.text = text\n    this.json = json\n    this.headers = headers\n  }\n\n  static async fromResponse(\n    response: Response,\n    url: string\n  ): Promise<FetchError> {\n    const status = response.status\n    const headers = Object.fromEntries([...response.headers.entries()])\n    let text: string | undefined = undefined\n    let json: object | undefined = undefined\n\n    const contentType = response.headers.get(`content-type`)\n    if (contentType && contentType.includes(`application/json`)) {\n      json = (await response.json()) as object\n    } else {\n      text = await response.text()\n    }\n\n    return new FetchError(status, text, json, headers, url)\n  }\n}\n\nexport class FetchBackoffAbortError extends Error {\n  constructor() {\n    super(`Fetch with backoff aborted`)\n  }\n}\n","export const LIVE_CACHE_BUSTER_HEADER = `electric-cursor`\nexport const SHAPE_HANDLE_HEADER = `electric-handle`\nexport const CHUNK_LAST_OFFSET_HEADER = `electric-offset`\nexport const SHAPE_SCHEMA_HEADER = `electric-schema`\nexport const CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`\nexport const DATABASE_ID_QUERY_PARAM = `database_id`\nexport const COLUMNS_QUERY_PARAM = `columns`\nexport const LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`\nexport const SHAPE_HANDLE_QUERY_PARAM = `handle`\nexport const LIVE_QUERY_PARAM = `live`\nexport const OFFSET_QUERY_PARAM = `offset`\nexport const TABLE_QUERY_PARAM = `table`\nexport const WHERE_QUERY_PARAM = `where`\nexport const REPLICA_PARAM = `replica`\n","import {\n  CHUNK_LAST_OFFSET_HEADER,\n  CHUNK_UP_TO_DATE_HEADER,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n} from './constants'\nimport { FetchError, FetchBackoffAbortError } from './error'\n\n// Some specific 4xx and 5xx HTTP status codes that we definitely\n// want to retry\nconst HTTP_RETRY_STATUS_CODES = [429]\n\nexport interface BackoffOptions {\n  /**\n   * Initial delay before retrying in milliseconds\n   */\n  initialDelay: number\n  /**\n   * Maximum retry delay in milliseconds\n   */\n  maxDelay: number\n  multiplier: number\n  onFailedAttempt?: () => void\n  debug?: boolean\n}\n\nexport const BackoffDefaults = {\n  initialDelay: 100,\n  maxDelay: 10_000,\n  multiplier: 1.3,\n}\n\nexport function createFetchWithBackoff(\n  fetchClient: typeof fetch,\n  backoffOptions: BackoffOptions = BackoffDefaults\n): typeof fetch {\n  const {\n    initialDelay,\n    maxDelay,\n    multiplier,\n    debug = false,\n    onFailedAttempt,\n  } = backoffOptions\n  return async (...args: Parameters<typeof fetch>): Promise<Response> => {\n    const url = args[0]\n    const options = args[1]\n\n    let delay = initialDelay\n    let attempt = 0\n\n    /* eslint-disable no-constant-condition -- we re-fetch the shape log\n     * continuously until we get a non-ok response. For recoverable errors,\n     * we retry the fetch with exponential backoff. Users can pass in an\n     * AbortController to abort the fetching an any point.\n     * */\n    while (true) {\n      /* eslint-enable no-constant-condition */\n      try {\n        const result = await fetchClient(...args)\n        if (result.ok) return result\n        else throw await FetchError.fromResponse(result, url.toString())\n      } catch (e) {\n        onFailedAttempt?.()\n        if (options?.signal?.aborted) {\n          throw new FetchBackoffAbortError()\n        } else if (\n          e instanceof FetchError &&\n          !HTTP_RETRY_STATUS_CODES.includes(e.status) &&\n          e.status >= 400 &&\n          e.status < 500\n        ) {\n          // Any client errors cannot be backed off on, leave it to the caller to handle.\n          throw e\n        } else {\n          // Exponentially backoff on errors.\n          // Wait for the current delay duration\n          await new Promise((resolve) => setTimeout(resolve, delay))\n\n          // Increase the delay for the next attempt\n          delay = Math.min(delay * multiplier, maxDelay)\n\n          if (debug) {\n            attempt++\n            console.log(`Retry attempt #${attempt} after ${delay}ms`)\n          }\n        }\n      }\n    }\n  }\n}\n\ninterface ChunkPrefetchOptions {\n  maxChunksToPrefetch: number\n}\n\nconst ChunkPrefetchDefaults = {\n  maxChunksToPrefetch: 2,\n}\n\n/**\n * Creates a fetch client that prefetches subsequent log chunks for\n * consumption by the shape stream without waiting for the chunk bodies\n * themselves to be loaded.\n *\n * @param fetchClient the client to wrap\n * @param prefetchOptions options to configure prefetching\n * @returns wrapped client with prefetch capabilities\n */\nexport function createFetchWithChunkBuffer(\n  fetchClient: typeof fetch,\n  prefetchOptions: ChunkPrefetchOptions = ChunkPrefetchDefaults\n): typeof fetch {\n  const { maxChunksToPrefetch } = prefetchOptions\n\n  let prefetchQueue: PrefetchQueue\n\n  const prefetchClient = async (...args: Parameters<typeof fetchClient>) => {\n    const url = args[0].toString()\n\n    // try to consume from the prefetch queue first, and if request is\n    // not present abort the prefetch queue as it must no longer be valid\n    const prefetchedRequest = prefetchQueue?.consume(...args)\n    if (prefetchedRequest) {\n      return prefetchedRequest\n    }\n\n    prefetchQueue?.abort()\n\n    // perform request and fire off prefetch queue if request is eligible\n    const response = await fetchClient(...args)\n    const nextUrl = getNextChunkUrl(url, response)\n    if (nextUrl) {\n      prefetchQueue = new PrefetchQueue({\n        fetchClient,\n        maxPrefetchedRequests: maxChunksToPrefetch,\n        url: nextUrl,\n        requestInit: args[1],\n      })\n    }\n\n    return response\n  }\n\n  return prefetchClient\n}\n\nclass PrefetchQueue {\n  readonly #fetchClient: typeof fetch\n  readonly #maxPrefetchedRequests: number\n  readonly #prefetchQueue = new Map<\n    string,\n    [Promise<Response>, AbortController]\n  >()\n  #queueHeadUrl: string | void\n  #queueTailUrl: string | void\n\n  constructor(options: {\n    url: Parameters<typeof fetch>[0]\n    requestInit: Parameters<typeof fetch>[1]\n    maxPrefetchedRequests: number\n    fetchClient?: typeof fetch\n  }) {\n    this.#fetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n    this.#maxPrefetchedRequests = options.maxPrefetchedRequests\n    this.#queueHeadUrl = options.url.toString()\n    this.#queueTailUrl = this.#queueHeadUrl\n    this.#prefetch(options.url, options.requestInit)\n  }\n\n  abort(): void {\n    this.#prefetchQueue.forEach(([_, aborter]) => aborter.abort())\n  }\n\n  consume(...args: Parameters<typeof fetch>): Promise<Response> | void {\n    const url = args[0].toString()\n\n    const request = this.#prefetchQueue.get(url)?.[0]\n    // only consume if request is in queue and is the queue \"head\"\n    // if request is in the queue but not the head, the queue is being\n    // consumed out of order and should be restarted\n    if (!request || url !== this.#queueHeadUrl) return\n    this.#prefetchQueue.delete(url)\n\n    // fire off new prefetch since request has been consumed\n    request\n      .then((response) => {\n        const nextUrl = getNextChunkUrl(url, response)\n        this.#queueHeadUrl = nextUrl\n        if (\n          this.#queueTailUrl &&\n          !this.#prefetchQueue.has(this.#queueTailUrl)\n        ) {\n          this.#prefetch(this.#queueTailUrl, args[1])\n        }\n      })\n      .catch(() => {})\n\n    return request\n  }\n\n  #prefetch(...args: Parameters<typeof fetch>): void {\n    const url = args[0].toString()\n\n    // only prefetch when queue is not full\n    if (this.#prefetchQueue.size >= this.#maxPrefetchedRequests) return\n\n    // initialize aborter per request, to avoid aborting consumed requests that\n    // are still streaming their bodies to the consumer\n    const aborter = new AbortController()\n\n    try {\n      const request = this.#fetchClient(url, {\n        ...(args[1] ?? {}),\n        signal: chainAborter(aborter, args[1]?.signal),\n      })\n      this.#prefetchQueue.set(url, [request, aborter])\n      request\n        .then((response) => {\n          // only keep prefetching if response chain is uninterrupted\n          if (!response.ok || aborter.signal.aborted) return\n\n          const nextUrl = getNextChunkUrl(url, response)\n\n          // only prefetch when there is a next URL\n          if (!nextUrl || nextUrl === url) {\n            this.#queueTailUrl = undefined\n            return\n          }\n\n          this.#queueTailUrl = nextUrl\n          return this.#prefetch(nextUrl, args[1])\n        })\n        .catch(() => {})\n    } catch (_) {\n      // ignore prefetch errors\n    }\n  }\n}\n\n/**\n * Generate the next chunk's URL if the url and response are valid\n */\nfunction getNextChunkUrl(url: string, res: Response): string | void {\n  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER)\n  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER)\n  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER)\n\n  // only prefetch if shape handle and offset for next chunk are available, and\n  // response is not already up-to-date\n  if (!shapeHandle || !lastOffset || isUpToDate) return\n\n  const nextUrl = new URL(url)\n\n  // don't prefetch live requests, rushing them will only\n  // potentially miss more recent data\n  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return\n\n  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle)\n  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset)\n  return nextUrl.toString()\n}\n\n/**\n * Chains an abort controller on an optional source signal's\n * aborted state - if the source signal is aborted, the provided abort\n * controller will also abort\n */\nfunction chainAborter(\n  aborter: AbortController,\n  sourceSignal?: AbortSignal | null\n): AbortSignal {\n  if (!sourceSignal) return aborter.signal\n  if (sourceSignal.aborted) aborter.abort()\n  else\n    sourceSignal.addEventListener(`abort`, () => aborter.abort(), {\n      once: true,\n    })\n  return aborter.signal\n}\n","import {\n  Message,\n  Offset,\n  Schema,\n  Row,\n  MaybePromise,\n  GetExtensions,\n} from './types'\nimport { MessageParser, Parser } from './parser'\nimport { isUpToDateMessage } from './helpers'\nimport { FetchError, FetchBackoffAbortError } from './error'\nimport {\n  BackoffDefaults,\n  BackoffOptions,\n  createFetchWithBackoff,\n  createFetchWithChunkBuffer,\n} from './fetch'\nimport {\n  CHUNK_LAST_OFFSET_HEADER,\n  LIVE_CACHE_BUSTER_HEADER,\n  LIVE_CACHE_BUSTER_QUERY_PARAM,\n  COLUMNS_QUERY_PARAM,\n  LIVE_QUERY_PARAM,\n  OFFSET_QUERY_PARAM,\n  SHAPE_HANDLE_HEADER,\n  SHAPE_HANDLE_QUERY_PARAM,\n  SHAPE_SCHEMA_HEADER,\n  WHERE_QUERY_PARAM,\n  DATABASE_ID_QUERY_PARAM,\n  TABLE_QUERY_PARAM,\n  REPLICA_PARAM,\n} from './constants'\n\ntype Replica = `full` | `default`\n\n/**\n * Options for constructing a ShapeStream.\n */\nexport interface ShapeStreamOptions<T = never> {\n  /**\n   * The full URL to where the Shape is served. This can either be the Electric server\n   * directly or a proxy. E.g. for a local Electric instance, you might set `http://localhost:3000/v1/shape`\n   */\n  url: string\n\n  /**\n   * Which database to use.\n   * This is optional unless Electric is used with multiple databases.\n   */\n  databaseId?: string\n\n  /**\n   * The root table for the shape. Passed as a query parameter. Not required if you set the table in your proxy.\n   */\n  table?: string\n\n  /**\n   * The where clauses for the shape.\n   */\n  where?: string\n\n  /**\n   * The columns to include in the shape.\n   * Must include primary keys, and can only inlude valid columns.\n   */\n  columns?: string[]\n\n  /**\n   * If `replica` is `default` (the default) then Electric will only send the\n   * changed columns in an update.\n   *\n   * If it's `full` Electric will send the entire row with both changed and\n   * unchanged values.\n   *\n   * Setting `replica` to `full` will obviously result in higher bandwidth\n   * usage and so is not recommended.\n   */\n  replica?: Replica\n  /**\n   * The \"offset\" on the shape log. This is typically not set as the ShapeStream\n   * will handle this automatically. A common scenario where you might pass an offset\n   * is if you're maintaining a local cache of the log. If you've gone offline\n   * and are re-starting a ShapeStream to catch-up to the latest state of the Shape,\n   * you'd pass in the last offset and shapeHandle you'd seen from the Electric server\n   * so it knows at what point in the shape to catch you up from.\n   */\n  offset?: Offset\n  /**\n   * Similar to `offset`, this isn't typically used unless you're maintaining\n   * a cache of the shape log.\n   */\n  shapeHandle?: string\n  backoffOptions?: BackoffOptions\n\n  /**\n   * HTTP headers to attach to requests made by the client.\n   * Can be used for adding authentication headers.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Automatically fetch updates to the Shape. If you just want to sync the current\n   * shape and stop, pass false.\n   */\n  subscribe?: boolean\n  signal?: AbortSignal\n  fetchClient?: typeof fetch\n  parser?: Parser<T>\n}\n\nexport interface ShapeStreamInterface<T extends Row<unknown> = Row> {\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ): void\n  unsubscribeAllUpToDateSubscribers(): void\n  unsubscribeAll(): void\n  subscribeOnceToUpToDate(\n    callback: () => MaybePromise<void>,\n    error: (err: FetchError | Error) => void\n  ): () => void\n\n  isLoading(): boolean\n  lastSyncedAt(): number | undefined\n  lastSynced(): number\n  isConnected(): boolean\n\n  isUpToDate: boolean\n  shapeHandle?: string\n}\n\n/**\n * Reads updates to a shape from Electric using HTTP requests and long polling. Notifies subscribers\n * when new messages come in. Doesn't maintain any history of the\n * log but does keep track of the offset position and is the best way\n * to consume the HTTP `GET /v1/shape` api.\n *\n * @constructor\n * @param {ShapeStreamOptions} options - configure the shape stream\n * @example\n * Register a callback function to subscribe to the messages.\n * ```\n * const stream = new ShapeStream(options)\n * stream.subscribe(messages => {\n *   // messages is 1 or more row updates\n * })\n * ```\n *\n * To abort the stream, abort the `signal`\n * passed in via the `ShapeStreamOptions`.\n * ```\n * const aborter = new AbortController()\n * const issueStream = new ShapeStream({\n *   url: `${BASE_URL}/${table}`\n *   subscribe: true,\n *   signal: aborter.signal,\n * })\n * // Later...\n * aborter.abort()\n * ```\n */\n\nexport class ShapeStream<T extends Row<unknown> = Row>\n  implements ShapeStreamInterface<T>\n{\n  static readonly Replica = {\n    FULL: `full` as Replica,\n    DEFAULT: `default` as Replica,\n  }\n\n  readonly options: ShapeStreamOptions<GetExtensions<T>>\n\n  readonly #fetchClient: typeof fetch\n  readonly #messageParser: MessageParser<T>\n\n  readonly #subscribers = new Map<\n    number,\n    [\n      (messages: Message<T>[]) => MaybePromise<void>,\n      ((error: Error) => void) | undefined,\n    ]\n  >()\n  readonly #upToDateSubscribers = new Map<\n    number,\n    [() => void, (error: FetchError | Error) => void]\n  >()\n\n  #lastOffset: Offset\n  #liveCacheBuster: string // Seconds since our Electric Epoch 😎\n  #lastSyncedAt?: number // unix time\n  #isUpToDate: boolean = false\n  #connected: boolean = false\n  #shapeHandle?: string\n  #databaseId?: string\n  #schema?: Schema\n  #error?: unknown\n  #replica?: Replica\n\n  constructor(options: ShapeStreamOptions<GetExtensions<T>>) {\n    validateOptions(options)\n    this.options = { subscribe: true, ...options }\n    this.#lastOffset = this.options.offset ?? `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = this.options.shapeHandle\n    this.#databaseId = this.options.databaseId\n    this.#messageParser = new MessageParser<T>(options.parser)\n    this.#replica = this.options.replica\n\n    const baseFetchClient =\n      options.fetchClient ??\n      ((...args: Parameters<typeof fetch>) => fetch(...args))\n\n    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, {\n      ...(options.backoffOptions ?? BackoffDefaults),\n      onFailedAttempt: () => {\n        this.#connected = false\n        options.backoffOptions?.onFailedAttempt?.()\n      },\n    })\n\n    this.#fetchClient = createFetchWithChunkBuffer(fetchWithBackoffClient)\n\n    this.start()\n  }\n\n  get shapeHandle() {\n    return this.#shapeHandle\n  }\n\n  get isUpToDate() {\n    return this.#isUpToDate\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  async start() {\n    this.#isUpToDate = false\n\n    const { url, table, where, columns, signal } = this.options\n\n    try {\n      while (\n        (!signal?.aborted && !this.#isUpToDate) ||\n        this.options.subscribe\n      ) {\n        const fetchUrl = new URL(url)\n        if (table) fetchUrl.searchParams.set(TABLE_QUERY_PARAM, table)\n        if (where) fetchUrl.searchParams.set(WHERE_QUERY_PARAM, where)\n        if (columns && columns.length > 0)\n          fetchUrl.searchParams.set(COLUMNS_QUERY_PARAM, columns.join(`,`))\n        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, this.#lastOffset)\n\n        if (this.#isUpToDate) {\n          fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`)\n          fetchUrl.searchParams.set(\n            LIVE_CACHE_BUSTER_QUERY_PARAM,\n            this.#liveCacheBuster\n          )\n        }\n\n        if (this.#shapeHandle) {\n          // This should probably be a header for better cache breaking?\n          fetchUrl.searchParams.set(\n            SHAPE_HANDLE_QUERY_PARAM,\n            this.#shapeHandle!\n          )\n        }\n\n        if (this.#databaseId) {\n          fetchUrl.searchParams.set(DATABASE_ID_QUERY_PARAM, this.#databaseId!)\n        }\n\n        if (\n          (this.#replica ?? ShapeStream.Replica.DEFAULT) !=\n          ShapeStream.Replica.DEFAULT\n        ) {\n          fetchUrl.searchParams.set(REPLICA_PARAM, this.#replica as string)\n        }\n\n        let response!: Response\n        try {\n          response = await this.#fetchClient(fetchUrl.toString(), {\n            signal,\n            headers: this.options.headers,\n          })\n          this.#connected = true\n        } catch (e) {\n          if (e instanceof FetchBackoffAbortError) break // interrupted\n          if (!(e instanceof FetchError)) throw e // should never happen\n          if (e.status == 409) {\n            // Upon receiving a 409, we should start from scratch\n            // with the newly provided shape handle\n            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER]\n            this.#reset(newShapeHandle)\n            await this.#publish(e.json as Message<T>[])\n            continue\n          } else if (e.status >= 400 && e.status < 500) {\n            // Notify subscribers\n            this.#sendErrorToUpToDateSubscribers(e)\n            this.#sendErrorToSubscribers(e)\n\n            // 400 errors are not actionable without additional user input,\n            // so we exit the loop\n            throw e\n          }\n        }\n\n        const { headers, status } = response\n        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER)\n        if (shapeHandle) {\n          this.#shapeHandle = shapeHandle\n        }\n\n        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER)\n        if (lastOffset) {\n          this.#lastOffset = lastOffset as Offset\n        }\n\n        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER)\n        if (liveCacheBuster) {\n          this.#liveCacheBuster = liveCacheBuster\n        }\n\n        const getSchema = (): Schema => {\n          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER)\n          return schemaHeader ? JSON.parse(schemaHeader) : {}\n        }\n        this.#schema = this.#schema ?? getSchema()\n\n        const messages = status === 204 ? `[]` : await response.text()\n\n        if (status === 204) {\n          // There's no content so we are live and up to date\n          this.#lastSyncedAt = Date.now()\n        }\n\n        const batch = this.#messageParser.parse(messages, this.#schema)\n\n        // Update isUpToDate\n        if (batch.length > 0) {\n          const prevUpToDate = this.#isUpToDate\n          const lastMessage = batch[batch.length - 1]\n          if (isUpToDateMessage(lastMessage)) {\n            this.#lastSyncedAt = Date.now()\n            this.#isUpToDate = true\n          }\n\n          await this.#publish(batch)\n          if (!prevUpToDate && this.#isUpToDate) {\n            this.#notifyUpToDateSubscribers()\n          }\n        }\n      }\n    } catch (err) {\n      this.#error = err\n    } finally {\n      this.#connected = false\n    }\n  }\n\n  subscribe(\n    callback: (messages: Message<T>[]) => MaybePromise<void>,\n    onError?: (error: FetchError | Error) => void\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, [callback, onError])\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  subscribeOnceToUpToDate(\n    callback: () => MaybePromise<void>,\n    error: (err: FetchError | Error) => void\n  ) {\n    const subscriptionId = Math.random()\n\n    this.#upToDateSubscribers.set(subscriptionId, [callback, error])\n\n    return () => {\n      this.#upToDateSubscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAllUpToDateSubscribers(): void {\n    this.#upToDateSubscribers.clear()\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.#lastSyncedAt\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced(): number {\n    if (this.#lastSyncedAt === undefined) return Infinity\n    return Date.now() - this.#lastSyncedAt\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#connected\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading(): boolean {\n    return !this.isUpToDate\n  }\n\n  async #publish(messages: Message<T>[]): Promise<void> {\n    await Promise.all(\n      Array.from(this.#subscribers.values()).map(async ([callback, __]) => {\n        try {\n          await callback(messages)\n        } catch (err) {\n          queueMicrotask(() => {\n            throw err\n          })\n        }\n      })\n    )\n  }\n\n  #sendErrorToSubscribers(error: Error) {\n    this.#subscribers.forEach(([_, errorFn]) => {\n      errorFn?.(error)\n    })\n  }\n\n  #notifyUpToDateSubscribers() {\n    this.#upToDateSubscribers.forEach(([callback]) => {\n      callback()\n    })\n  }\n\n  #sendErrorToUpToDateSubscribers(error: FetchError | Error) {\n    this.#upToDateSubscribers.forEach(([_, errorCallback]) =>\n      errorCallback(error)\n    )\n  }\n\n  /**\n   * Resets the state of the stream, optionally with a provided\n   * shape handle\n   */\n  #reset(shapeHandle?: string) {\n    this.#lastOffset = `-1`\n    this.#liveCacheBuster = ``\n    this.#shapeHandle = shapeHandle\n    this.#isUpToDate = false\n    this.#connected = false\n    this.#schema = undefined\n  }\n}\n\nfunction validateOptions<T>(options: Partial<ShapeStreamOptions<T>>): void {\n  if (!options.url) {\n    throw new Error(`Invalid shape options. It must provide the url`)\n  }\n  if (options.signal && !(options.signal instanceof AbortSignal)) {\n    throw new Error(\n      `Invalid signal option. It must be an instance of AbortSignal.`\n    )\n  }\n\n  if (\n    options.offset !== undefined &&\n    options.offset !== `-1` &&\n    !options.shapeHandle\n  ) {\n    throw new Error(\n      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`\n    )\n  }\n  return\n}\n","import { Message, Row } from './types'\nimport { isChangeMessage, isControlMessage } from './helpers'\nimport { FetchError } from './error'\nimport { ShapeStreamInterface } from './client'\n\nexport type ShapeData<T extends Row<unknown> = Row> = Map<string, T>\nexport type ShapeChangedCallback<T extends Row<unknown> = Row> = (data: {\n  value: ShapeData<T>\n  rows: T[]\n}) => void\n\n/**\n * A Shape is an object that subscribes to a shape log,\n * keeps a materialised shape `.rows` in memory and\n * notifies subscribers when the value has changed.\n *\n * It can be used without a framework and as a primitive\n * to simplify developing framework hooks.\n *\n * @constructor\n * @param {ShapeStream<T extends Row>} - the underlying shape stream\n * @example\n * ```\n * const shapeStream = new ShapeStream<{ foo: number }>(url: `http://localhost:3000/v1/shape`, table: `foo`})\n * const shape = new Shape(shapeStream)\n * ```\n *\n * `rows` returns a promise that resolves the Shape data once the Shape has been\n * fully loaded (and when resuming from being offline):\n *\n *     const rows = await shape.rows\n *\n * `currentRows` returns the current data synchronously:\n *\n *     const rows = shape.currentRows\n *\n *  Subscribe to updates. Called whenever the shape updates in Postgres.\n *\n *     shape.subscribe(({ rows }) => {\n *       console.log(rows)\n *     })\n */\nexport class Shape<T extends Row<unknown> = Row> {\n  readonly #stream: ShapeStreamInterface<T>\n\n  readonly #data: ShapeData<T> = new Map()\n  readonly #subscribers = new Map<number, ShapeChangedCallback<T>>()\n\n  #hasNotifiedSubscribersUpToDate: boolean = false\n  #error: FetchError | false = false\n\n  constructor(stream: ShapeStreamInterface<T>) {\n    this.#stream = stream\n    this.#stream.subscribe(\n      this.#process.bind(this),\n      this.#handleError.bind(this)\n    )\n    const unsubscribe = this.#stream.subscribeOnceToUpToDate(\n      () => {\n        unsubscribe()\n      },\n      (e) => {\n        this.#handleError(e)\n        throw e\n      }\n    )\n  }\n\n  get isUpToDate(): boolean {\n    return this.#stream.isUpToDate\n  }\n\n  get rows(): Promise<T[]> {\n    return this.value.then((v) => Array.from(v.values()))\n  }\n\n  get currentRows(): T[] {\n    return Array.from(this.currentValue.values())\n  }\n\n  get value(): Promise<ShapeData<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.#stream.isUpToDate) {\n        resolve(this.currentValue)\n      } else {\n        const unsubscribe = this.subscribe(({ value }) => {\n          unsubscribe()\n          if (this.#error) reject(this.#error)\n          resolve(value)\n        })\n      }\n    })\n  }\n\n  get currentValue() {\n    return this.#data\n  }\n\n  get error() {\n    return this.#error\n  }\n\n  /** Unix time at which we last synced. Undefined when `isLoading` is true. */\n  lastSyncedAt(): number | undefined {\n    return this.#stream.lastSyncedAt()\n  }\n\n  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */\n  lastSynced() {\n    return this.#stream.lastSynced()\n  }\n\n  /** True during initial fetch. False afterwise.  */\n  isLoading() {\n    return this.#stream.isLoading()\n  }\n\n  /** Indicates if we are connected to the Electric sync service. */\n  isConnected(): boolean {\n    return this.#stream.isConnected()\n  }\n\n  subscribe(callback: ShapeChangedCallback<T>): () => void {\n    const subscriptionId = Math.random()\n\n    this.#subscribers.set(subscriptionId, callback)\n\n    return () => {\n      this.#subscribers.delete(subscriptionId)\n    }\n  }\n\n  unsubscribeAll(): void {\n    this.#subscribers.clear()\n  }\n\n  get numSubscribers() {\n    return this.#subscribers.size\n  }\n\n  #process(messages: Message<T>[]): void {\n    let dataMayHaveChanged = false\n    let isUpToDate = false\n    let newlyUpToDate = false\n\n    messages.forEach((message) => {\n      if (isChangeMessage(message)) {\n        dataMayHaveChanged = [`insert`, `update`, `delete`].includes(\n          message.headers.operation\n        )\n\n        switch (message.headers.operation) {\n          case `insert`:\n            this.#data.set(message.key, message.value)\n            break\n          case `update`:\n            this.#data.set(message.key, {\n              ...this.#data.get(message.key)!,\n              ...message.value,\n            })\n            break\n          case `delete`:\n            this.#data.delete(message.key)\n            break\n        }\n      }\n\n      if (isControlMessage(message)) {\n        switch (message.headers.control) {\n          case `up-to-date`:\n            isUpToDate = true\n            if (!this.#hasNotifiedSubscribersUpToDate) {\n              newlyUpToDate = true\n            }\n            break\n          case `must-refetch`:\n            this.#data.clear()\n            this.#error = false\n            this.#hasNotifiedSubscribersUpToDate = false\n            isUpToDate = false\n            newlyUpToDate = false\n            break\n        }\n      }\n    })\n\n    // Always notify subscribers when the Shape first is up to date.\n    // FIXME this would be cleaner with a simple state machine.\n    if (newlyUpToDate || (isUpToDate && dataMayHaveChanged)) {\n      this.#hasNotifiedSubscribersUpToDate = true\n      this.#notify()\n    }\n  }\n\n  #handleError(e: Error): void {\n    if (e instanceof FetchError) {\n      this.#error = e\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    this.#subscribers.forEach((callback) => {\n      callback({ value: this.currentValue, rows: this.currentRows })\n    })\n  }\n}\n"],"mappings":"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","names":["parseNumber","value","parseBool","parseBigInt","parseJson","identityParser","v","defaultParser","pgArrayParser","parser","i","char","str","quoted","last","p","loop","x","xs","MessageParser","__spreadValues","messages","schema","key","row","_b","columnInfo","_a","typ","dimensions","additionalInfo","__objRest","typeParser","makeNullableParser","_","columnName","isNullable","isPgNull","isChangeMessage","message","isControlMessage","isUpToDateMessage","FetchError","_FetchError","status","text","json","headers","url","message","response","__async","contentType","FetchBackoffAbortError","LIVE_CACHE_BUSTER_HEADER","SHAPE_HANDLE_HEADER","CHUNK_LAST_OFFSET_HEADER","SHAPE_SCHEMA_HEADER","CHUNK_UP_TO_DATE_HEADER","DATABASE_ID_QUERY_PARAM","COLUMNS_QUERY_PARAM","LIVE_CACHE_BUSTER_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","LIVE_QUERY_PARAM","OFFSET_QUERY_PARAM","TABLE_QUERY_PARAM","WHERE_QUERY_PARAM","REPLICA_PARAM","HTTP_RETRY_STATUS_CODES","BackoffDefaults","createFetchWithBackoff","fetchClient","backoffOptions","initialDelay","maxDelay","multiplier","debug","onFailedAttempt","args","__async","_a","url","options","delay","attempt","result","FetchError","e","FetchBackoffAbortError","resolve","ChunkPrefetchDefaults","createFetchWithChunkBuffer","prefetchOptions","maxChunksToPrefetch","prefetchQueue","prefetchedRequest","response","nextUrl","getNextChunkUrl","PrefetchQueue","_fetchClient","_maxPrefetchedRequests","_prefetchQueue","_queueHeadUrl","_queueTailUrl","_PrefetchQueue_instances","prefetch_fn","__privateAdd","__privateSet","__privateGet","__privateMethod","_","aborter","request","_b","__spreadProps","__spreadValues","chainAborter","res","shapeHandle","SHAPE_HANDLE_HEADER","lastOffset","CHUNK_LAST_OFFSET_HEADER","isUpToDate","CHUNK_UP_TO_DATE_HEADER","LIVE_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","OFFSET_QUERY_PARAM","sourceSignal","_fetchClient","_messageParser","_subscribers","_upToDateSubscribers","_lastOffset","_liveCacheBuster","_lastSyncedAt","_isUpToDate","_connected","_shapeHandle","_databaseId","_schema","_error","_replica","_ShapeStream_instances","publish_fn","sendErrorToSubscribers_fn","notifyUpToDateSubscribers_fn","sendErrorToUpToDateSubscribers_fn","reset_fn","_ShapeStream","options","__privateAdd","_a","_b","_c","validateOptions","__spreadValues","__privateSet","MessageParser","baseFetchClient","args","fetchWithBackoffClient","createFetchWithBackoff","__spreadProps","BackoffDefaults","createFetchWithChunkBuffer","__privateGet","__async","url","table","where","columns","signal","fetchUrl","TABLE_QUERY_PARAM","WHERE_QUERY_PARAM","COLUMNS_QUERY_PARAM","OFFSET_QUERY_PARAM","LIVE_QUERY_PARAM","LIVE_CACHE_BUSTER_QUERY_PARAM","SHAPE_HANDLE_QUERY_PARAM","DATABASE_ID_QUERY_PARAM","REPLICA_PARAM","response","e","FetchBackoffAbortError","FetchError","newShapeHandle","SHAPE_HANDLE_HEADER","__privateMethod","headers","status","shapeHandle","lastOffset","CHUNK_LAST_OFFSET_HEADER","liveCacheBuster","LIVE_CACHE_BUSTER_HEADER","getSchema","schemaHeader","SHAPE_SCHEMA_HEADER","messages","batch","prevUpToDate","lastMessage","isUpToDateMessage","err","callback","onError","subscriptionId","error","_0","__","_","errorFn","errorCallback","ShapeStream","_stream","_data","_subscribers","_hasNotifiedSubscribersUpToDate","_error","_Shape_instances","process_fn","handleError_fn","notify_fn","Shape","stream","__privateAdd","__privateSet","__privateGet","__privateMethod","unsubscribe","e","v","resolve","reject","value","callback","subscriptionId","messages","dataMayHaveChanged","isUpToDate","newlyUpToDate","message","isChangeMessage","__spreadValues","isControlMessage","FetchError"]}