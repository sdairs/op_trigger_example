"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataStream = void 0;
class MetadataStream {
    options;
    controller = new AbortController();
    serverQueue = [];
    consumerQueue = [];
    serverIterator;
    consumerIterator;
    streamPromise;
    constructor(options) {
        this.options = options;
        const { serverIterator, consumerIterator } = this.createTeeIterators();
        this.serverIterator = serverIterator;
        this.consumerIterator = consumerIterator;
        this.streamPromise = this.initializeServerStream();
    }
    createTeeIterators() {
        const teeIterator = (queue) => ({
            next: () => {
                if (queue.length === 0) {
                    const result = this.options.iterator.next();
                    this.serverQueue.push(result);
                    this.consumerQueue.push(result);
                }
                return queue.shift();
            },
        });
        return {
            serverIterator: teeIterator(this.serverQueue),
            consumerIterator: teeIterator(this.consumerQueue),
        };
    }
    initializeServerStream() {
        const serverIterator = this.serverIterator;
        // TODO: Why is this only sending stuff to the server at the end of the run?
        const serverStream = new ReadableStream({
            async pull(controller) {
                try {
                    const { value, done } = await serverIterator.next();
                    if (done) {
                        controller.close();
                        return;
                    }
                    controller.enqueue(JSON.stringify(value) + "\n");
                }
                catch (err) {
                    controller.error(err);
                }
            },
            cancel: () => this.controller.abort(),
        });
        return fetch(`${this.options.baseUrl}/realtime/v1/streams/${this.options.runId}/${this.options.key}`, {
            method: "POST",
            headers: {},
            body: serverStream,
            // @ts-expect-error
            duplex: "half",
            signal: this.controller.signal,
        });
    }
    async wait() {
        return this.streamPromise.then(() => void 0);
    }
    [Symbol.asyncIterator]() {
        return this.consumerIterator;
    }
}
exports.MetadataStream = MetadataStream;
//# sourceMappingURL=metadataStream.js.map