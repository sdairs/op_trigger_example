import { z } from "zod";
import { AddTagsRequestBody, BatchTaskRunExecutionResult, BatchTriggerTaskV2RequestBody, CreateEnvironmentVariableRequestBody, CreateScheduleOptions, ListRunResponseItem, ListScheduleOptions, RescheduleRunRequestBody, TaskRunExecutionResult, TriggerTaskRequestBody, UpdateEnvironmentVariableRequestBody, UpdateMetadataRequestBody, UpdateScheduleOptions } from "../schemas/index.js";
import { AnyRunTypes, TriggerJwtOptions } from "../types/tasks.js";
import { ApiRequestOptions, CursorPagePromise, ZodFetchOptions, isRequestOptions } from "./core.js";
import { AnyRunShape, RealtimeRun, AnyRealtimeRun, RunShape, RunStreamCallback, RunSubscription, TaskRunShape } from "./runStream.js";
import { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, ListProjectRunsQueryParams, ListRunsQueryParams, SubscribeToRunsQueryParams, UpdateEnvironmentVariableParams } from "./types.js";
export type { CreateEnvironmentVariableParams, ImportEnvironmentVariablesParams, SubscribeToRunsQueryParams, UpdateEnvironmentVariableParams, };
export type ClientTriggerOptions = {
    spanParentAsLink?: boolean;
};
export type ClientBatchTriggerOptions = ClientTriggerOptions & {
    idempotencyKey?: string;
    idempotencyKeyTTL?: string;
};
export type TriggerRequestOptions = ZodFetchOptions & {
    publicAccessToken?: TriggerJwtOptions;
};
export type TriggerApiRequestOptions = ApiRequestOptions & {
    publicAccessToken?: TriggerJwtOptions;
};
export { isRequestOptions };
export type { AnyRunShape, ApiRequestOptions, RealtimeRun, AnyRealtimeRun, RunShape, RunStreamCallback, RunSubscription, TaskRunShape, };
/**
 * Trigger.dev v3 API client
 */
export declare class ApiClient {
    #private;
    readonly baseUrl: string;
    readonly accessToken: string;
    private readonly defaultRequestOptions;
    constructor(baseUrl: string, accessToken: string, requestOptions?: ApiRequestOptions);
    get fetchClient(): typeof fetch;
    getRunResult(runId: string, requestOptions?: ZodFetchOptions): Promise<TaskRunExecutionResult | undefined>;
    getBatchResults(batchId: string, requestOptions?: ZodFetchOptions): Promise<BatchTaskRunExecutionResult | undefined>;
    triggerTask(taskId: string, body: TriggerTaskRequestBody, clientOptions?: ClientTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
    }>;
    batchTriggerV2(body: BatchTriggerTaskV2RequestBody, clientOptions?: ClientBatchTriggerOptions, requestOptions?: TriggerRequestOptions): Promise<{
        publicAccessToken: string;
        id: string;
        runs: {
            id: string;
            taskIdentifier: string;
            isCached: boolean;
            idempotencyKey?: string | undefined;
        }[];
        isCached: boolean;
        idempotencyKey?: string | undefined;
    }>;
    createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        presignedUrl: string;
    }>;
    getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        presignedUrl: string;
    }>;
    retrieveRun(runId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
        id: string;
        attempts: ({
            status: "PENDING" | "COMPLETED" | "CANCELED" | "EXECUTING" | "FAILED" | "PAUSED";
            id: string;
            updatedAt: Date;
            createdAt: Date;
            startedAt?: Date | undefined;
            completedAt?: Date | undefined;
            error?: {
                message: string;
                name?: string | undefined;
                stackTrace?: string | undefined;
            } | undefined;
        } | undefined)[];
        updatedAt: Date;
        isTest: boolean;
        createdAt: Date;
        tags: string[];
        durationMs: number;
        costInCents: number;
        baseCostInCents: number;
        taskIdentifier: string;
        relatedRuns: {
            root?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                version?: string | undefined;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                version?: string | undefined;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                version?: string | undefined;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        depth: number;
        triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
        isQueued: boolean;
        isExecuting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        attemptCount: number;
        payload?: any;
        version?: string | undefined;
        metadata?: Record<string, any> | undefined;
        startedAt?: Date | undefined;
        output?: any;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
        idempotencyKey?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        ttl?: string | undefined;
        payloadPresignedUrl?: string | undefined;
        outputPresignedUrl?: string | undefined;
        batchId?: string | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        expiredAt?: Date | undefined;
    }>;
    listRuns(query?: ListRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    listProjectRuns(projectRef: string, query?: ListProjectRunsQueryParams, requestOptions?: ZodFetchOptions): CursorPagePromise<typeof ListRunResponseItem>;
    replayRun(runId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    cancelRun(runId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
        id: string;
        attempts: ({
            status: "PENDING" | "COMPLETED" | "CANCELED" | "EXECUTING" | "FAILED" | "PAUSED";
            id: string;
            updatedAt: Date;
            createdAt: Date;
            startedAt?: Date | undefined;
            completedAt?: Date | undefined;
            error?: {
                message: string;
                name?: string | undefined;
                stackTrace?: string | undefined;
            } | undefined;
        } | undefined)[];
        updatedAt: Date;
        isTest: boolean;
        createdAt: Date;
        tags: string[];
        durationMs: number;
        costInCents: number;
        baseCostInCents: number;
        taskIdentifier: string;
        relatedRuns: {
            root?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                version?: string | undefined;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            parent?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                version?: string | undefined;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            } | undefined;
            children?: {
                status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
                id: string;
                updatedAt: Date;
                isTest: boolean;
                createdAt: Date;
                tags: string[];
                durationMs: number;
                costInCents: number;
                baseCostInCents: number;
                taskIdentifier: string;
                depth: number;
                triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
                isQueued: boolean;
                isExecuting: boolean;
                isCompleted: boolean;
                isSuccess: boolean;
                isFailed: boolean;
                isCancelled: boolean;
                version?: string | undefined;
                metadata?: Record<string, any> | undefined;
                startedAt?: Date | undefined;
                idempotencyKey?: string | undefined;
                ttl?: string | undefined;
                batchId?: string | undefined;
                finishedAt?: Date | undefined;
                delayedUntil?: Date | undefined;
                expiredAt?: Date | undefined;
            }[] | undefined;
        };
        depth: number;
        triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
        isQueued: boolean;
        isExecuting: boolean;
        isCompleted: boolean;
        isSuccess: boolean;
        isFailed: boolean;
        isCancelled: boolean;
        attemptCount: number;
        payload?: any;
        version?: string | undefined;
        metadata?: Record<string, any> | undefined;
        startedAt?: Date | undefined;
        output?: any;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
        idempotencyKey?: string | undefined;
        schedule?: {
            id: string;
            generator: {
                type: "CRON";
                description: string;
                expression: string;
            };
            externalId?: string | undefined;
            deduplicationKey?: string | undefined;
        } | undefined;
        ttl?: string | undefined;
        payloadPresignedUrl?: string | undefined;
        outputPresignedUrl?: string | undefined;
        batchId?: string | undefined;
        finishedAt?: Date | undefined;
        delayedUntil?: Date | undefined;
        expiredAt?: Date | undefined;
    }>;
    addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        message: string;
    }>;
    createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").OffsetLimitPagePromise<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodUnion<[z.ZodLiteral<"DECLARATIVE">, z.ZodLiteral<"IMPERATIVE">]>;
        task: z.ZodString;
        active: z.ZodBoolean;
        deduplicationKey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        externalId: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        generator: z.ZodObject<{
            type: z.ZodLiteral<"CRON">;
            expression: z.ZodString;
            description: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type: "CRON";
            description: string;
            expression: string;
        }, {
            type: "CRON";
            description: string;
            expression: string;
        }>;
        timezone: z.ZodString;
        nextRun: z.ZodOptional<z.ZodNullable<z.ZodDate>>;
        environments: z.ZodArray<z.ZodObject<{
            id: z.ZodString;
            type: z.ZodString;
            userName: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }, {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }, {
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>>;
    retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    updateSchedule(scheduleId: string, options: UpdateScheduleOptions, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        type: "DECLARATIVE" | "IMPERATIVE";
        id: string;
        active: boolean;
        task: string;
        timezone: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        environments: {
            type: string;
            id: string;
            userName?: string | null | undefined;
        }[];
        externalId?: string | null | undefined;
        deduplicationKey?: string | null | undefined;
        nextRun?: Date | null | undefined;
    }>;
    deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        id: string;
    }>;
    listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        value: string;
        name: string;
    }[]>;
    importEnvVars(projectRef: string, slug: string, body: ImportEnvironmentVariablesParams, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        value: string;
    }>;
    createEnvVar(projectRef: string, slug: string, body: CreateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    updateEnvVar(projectRef: string, slug: string, key: string, body: UpdateEnvironmentVariableRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        success: boolean;
    }>;
    updateRunMetadata(runId: string, body: UpdateMetadataRequestBody, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        metadata: Record<string, import("../../index.js").DeserializedJson>;
    }>;
    subscribeToRun<TRunTypes extends AnyRunTypes>(runId: string, options?: {
        signal?: AbortSignal;
    }): RunSubscription<TRunTypes>;
    subscribeToRunsWithTag<TRunTypes extends AnyRunTypes>(tag: string | string[], options?: {
        signal?: AbortSignal;
    }): RunSubscription<TRunTypes>;
    subscribeToBatch<TRunTypes extends AnyRunTypes>(batchId: string, options?: {
        signal?: AbortSignal;
    }): RunSubscription<TRunTypes>;
    generateJWTClaims(requestOptions?: ZodFetchOptions): Promise<Record<string, any>>;
    retrieveBatch(batchId: string, requestOptions?: ZodFetchOptions): import("./core.js").ApiPromise<{
        status: "PENDING" | "COMPLETED";
        id: string;
        updatedAt: Date;
        createdAt: Date;
        runCount: number;
        idempotencyKey?: string | undefined;
    }>;
}
export declare function mergeRequestOptions(defaultOptions: ZodFetchOptions, options?: ApiRequestOptions): ZodFetchOptions;
