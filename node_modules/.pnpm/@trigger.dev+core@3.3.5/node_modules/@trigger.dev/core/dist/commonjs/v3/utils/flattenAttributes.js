"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CIRCULAR_REFERENCE_SENTINEL = exports.NULL_SENTINEL = void 0;
exports.flattenAttributes = flattenAttributes;
exports.unflattenAttributes = unflattenAttributes;
exports.primitiveValueOrflattenedAttributes = primitiveValueOrflattenedAttributes;
exports.NULL_SENTINEL = "$@null((";
exports.CIRCULAR_REFERENCE_SENTINEL = "$@circular((";
function flattenAttributes(obj, prefix, seen = new WeakSet()) {
    const result = {};
    // Check if obj is null or undefined
    if (obj === undefined) {
        return result;
    }
    if (obj === null) {
        result[prefix || ""] = exports.NULL_SENTINEL;
        return result;
    }
    if (typeof obj === "string") {
        result[prefix || ""] = obj;
        return result;
    }
    if (typeof obj === "number") {
        result[prefix || ""] = obj;
        return result;
    }
    if (typeof obj === "boolean") {
        result[prefix || ""] = obj;
        return result;
    }
    if (obj instanceof Date) {
        result[prefix || ""] = obj.toISOString();
        return result;
    }
    // Check for circular reference
    if (obj !== null && typeof obj === "object" && seen.has(obj)) {
        result[prefix || ""] = exports.CIRCULAR_REFERENCE_SENTINEL;
        return result;
    }
    // Add object to seen set
    if (obj !== null && typeof obj === "object") {
        seen.add(obj);
    }
    for (const [key, value] of Object.entries(obj)) {
        const newPrefix = `${prefix ? `${prefix}.` : ""}${Array.isArray(obj) ? `[${key}]` : key}`;
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                if (typeof value[i] === "object" && value[i] !== null) {
                    // update null check here as well
                    Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`, seen));
                }
                else {
                    if (value[i] === null) {
                        result[`${newPrefix}.[${i}]`] = exports.NULL_SENTINEL;
                    }
                    else {
                        result[`${newPrefix}.[${i}]`] = value[i];
                    }
                }
            }
        }
        else if (isRecord(value)) {
            // update null check here
            Object.assign(result, flattenAttributes(value, newPrefix, seen));
        }
        else {
            if (typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
                result[newPrefix] = value;
            }
            else if (value === null) {
                result[newPrefix] = exports.NULL_SENTINEL;
            }
        }
    }
    return result;
}
function isRecord(value) {
    return value !== null && typeof value === "object" && !Array.isArray(value);
}
function unflattenAttributes(obj) {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return obj;
    }
    if (typeof obj === "object" &&
        obj !== null &&
        Object.keys(obj).length === 1 &&
        Object.keys(obj)[0] === "") {
        return rehydrateNull(obj[""]);
    }
    if (Object.keys(obj).length === 0) {
        return;
    }
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        const parts = key.split(".").reduce((acc, part) => {
            if (part.startsWith("[") && part.endsWith("]")) {
                // Handle array indices more precisely
                const match = part.match(/^\[(\d+)\]$/);
                if (match && match[1]) {
                    acc.push(parseInt(match[1]));
                }
                else {
                    // Remove brackets for non-numeric array keys
                    acc.push(part.slice(1, -1));
                }
            }
            else {
                acc.push(part);
            }
            return acc;
        }, []);
        let current = result;
        for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            const nextPart = parts[i + 1];
            if (!part && part !== 0) {
                continue;
            }
            if (typeof nextPart === "number") {
                // Ensure we create an array for numeric indices
                current[part] = Array.isArray(current[part]) ? current[part] : [];
            }
            else if (current[part] === undefined) {
                // Create an object for non-numeric paths
                current[part] = {};
            }
            current = current[part];
        }
        const lastPart = parts[parts.length - 1];
        if (lastPart !== undefined) {
            current[lastPart] = rehydrateNull(rehydrateCircular(value));
        }
    }
    // Convert the result to an array if all top-level keys are numeric indices
    if (Object.keys(result).every((k) => /^\d+$/.test(k))) {
        const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));
        const arrayResult = Array(maxIndex + 1);
        for (const key in result) {
            arrayResult[parseInt(key)] = result[key];
        }
        return arrayResult;
    }
    return result;
}
function rehydrateCircular(value) {
    if (value === exports.CIRCULAR_REFERENCE_SENTINEL) {
        return "[Circular Reference]";
    }
    return value;
}
function primitiveValueOrflattenedAttributes(obj, prefix) {
    if (typeof obj === "string" ||
        typeof obj === "number" ||
        typeof obj === "boolean" ||
        obj === null ||
        obj === undefined) {
        return obj;
    }
    const attributes = flattenAttributes(obj, prefix);
    if (prefix !== undefined &&
        typeof attributes[prefix] !== "undefined" &&
        attributes[prefix] !== null) {
        return attributes[prefix];
    }
    return attributes;
}
function rehydrateNull(value) {
    if (value === exports.NULL_SENTINEL) {
        return null;
    }
    return value;
}
//# sourceMappingURL=flattenAttributes.js.map