import { createJsonErrorObject } from "../errors.js";
import { SubscribeRunRawShape } from "../schemas/api.js";
import { getEnvVar } from "../utils/getEnv.js";
import { conditionallyImportAndParsePacket, parsePacket, } from "../utils/ioSerialization.js";
import { ApiError } from "./errors.js";
import { createAsyncIterableStream, zodShapeStream } from "./stream.js";
import { EventSourceParserStream } from "eventsource-parser/stream";
export function runShapeStream(url, options) {
    const $options = {
        provider: {
            async onShape(callback) {
                return zodShapeStream(SubscribeRunRawShape, url, callback, options);
            },
        },
        streamFactory: new SSEStreamSubscriptionFactory(getEnvVar("TRIGGER_STREAM_URL", getEnvVar("TRIGGER_API_URL")) ?? "https://api.trigger.dev", {
            headers: options?.headers,
            signal: options?.signal,
        }),
        ...options,
    };
    return new RunSubscription($options);
}
// Real implementation for production
export class SSEStreamSubscription {
    url;
    options;
    constructor(url, options) {
        this.url = url;
        this.options = options;
    }
    async subscribe() {
        return fetch(this.url, {
            headers: {
                Accept: "text/event-stream",
                ...this.options.headers,
            },
            signal: this.options.signal,
        }).then((response) => {
            if (!response.ok) {
                throw ApiError.generate(response.status, {}, "Could not subscribe to stream", Object.fromEntries(response.headers));
            }
            if (!response.body) {
                throw new Error("No response body");
            }
            return response.body
                .pipeThrough(new TextDecoderStream())
                .pipeThrough(new EventSourceParserStream())
                .pipeThrough(new TransformStream({
                transform(chunk, controller) {
                    controller.enqueue(safeParseJSON(chunk.data));
                },
            }));
        });
    }
}
export class SSEStreamSubscriptionFactory {
    baseUrl;
    options;
    constructor(baseUrl, options) {
        this.baseUrl = baseUrl;
        this.options = options;
    }
    createSubscription(runId, streamKey, baseUrl) {
        if (!runId || !streamKey) {
            throw new Error("runId and streamKey are required");
        }
        const url = `${baseUrl ?? this.baseUrl}/realtime/v1/streams/${runId}/${streamKey}`;
        return new SSEStreamSubscription(url, this.options);
    }
}
export class RunSubscription {
    options;
    abortController;
    unsubscribeShape;
    stream;
    packetCache = new Map();
    _closeOnComplete;
    _isRunComplete = false;
    constructor(options) {
        this.options = options;
        this.abortController = new AbortController();
        this._closeOnComplete =
            typeof options.closeOnComplete === "undefined" ? true : options.closeOnComplete;
        const source = new ReadableStream({
            start: async (controller) => {
                this.unsubscribeShape = await this.options.provider.onShape(async (shape) => {
                    controller.enqueue(shape);
                    this._isRunComplete = !!shape.completedAt;
                    if (this._closeOnComplete &&
                        this._isRunComplete &&
                        !this.abortController.signal.aborted) {
                        controller.close();
                        this.abortController.abort();
                    }
                });
            },
            cancel: () => {
                this.unsubscribe();
            },
        });
        this.stream = createAsyncIterableStream(source, {
            transform: async (chunk, controller) => {
                const run = await this.transformRunShape(chunk);
                controller.enqueue(run);
            },
        });
    }
    unsubscribe() {
        if (!this.abortController.signal.aborted) {
            this.abortController.abort();
        }
        this.unsubscribeShape?.();
    }
    [Symbol.asyncIterator]() {
        return this.stream[Symbol.asyncIterator]();
    }
    getReader() {
        return this.stream.getReader();
    }
    withStreams() {
        // Keep track of which streams we've already subscribed to
        const activeStreams = new Set();
        return createAsyncIterableStream(this.stream, {
            transform: async (run, controller) => {
                controller.enqueue({
                    type: "run",
                    run,
                });
                // Check for stream metadata
                if (run.metadata && "$$streams" in run.metadata && Array.isArray(run.metadata.$$streams)) {
                    for (const streamKey of run.metadata.$$streams) {
                        if (typeof streamKey !== "string") {
                            continue;
                        }
                        if (!activeStreams.has(streamKey)) {
                            activeStreams.add(streamKey);
                            const subscription = this.options.streamFactory.createSubscription(run.id, streamKey, this.options.client?.baseUrl);
                            const stream = await subscription.subscribe();
                            // Create the pipeline and start it
                            stream
                                .pipeThrough(new TransformStream({
                                transform(chunk, controller) {
                                    controller.enqueue({
                                        type: streamKey,
                                        chunk: chunk,
                                        run,
                                    });
                                },
                            }))
                                .pipeTo(new WritableStream({
                                write(chunk) {
                                    controller.enqueue(chunk);
                                },
                            }))
                                .catch((error) => {
                                console.error(`Error in stream ${streamKey}:`, error);
                            });
                        }
                    }
                }
            },
        });
    }
    async transformRunShape(row) {
        const payloadPacket = row.payloadType
            ? { data: row.payload ?? undefined, dataType: row.payloadType }
            : undefined;
        const outputPacket = row.outputType
            ? { data: row.output ?? undefined, dataType: row.outputType }
            : undefined;
        const [payload, output] = await Promise.all([
            { packet: payloadPacket, key: "payload" },
            { packet: outputPacket, key: "output" },
        ].map(async ({ packet, key }) => {
            if (!packet) {
                return;
            }
            const cachedResult = this.packetCache.get(`${row.friendlyId}/${key}`);
            if (typeof cachedResult !== "undefined") {
                return cachedResult;
            }
            const result = await conditionallyImportAndParsePacket(packet, this.options.client);
            this.packetCache.set(`${row.friendlyId}/${key}`, result);
            return result;
        }));
        const metadata = row.metadata && row.metadataType
            ? await parsePacket({ data: row.metadata, dataType: row.metadataType })
            : undefined;
        return {
            id: row.friendlyId,
            payload,
            output,
            createdAt: row.createdAt,
            updatedAt: row.updatedAt,
            taskIdentifier: row.taskIdentifier,
            number: row.number,
            status: apiStatusFromRunStatus(row.status),
            durationMs: row.usageDurationMs,
            costInCents: row.costInCents,
            baseCostInCents: row.baseCostInCents,
            tags: row.runTags ?? [],
            idempotencyKey: row.idempotencyKey ?? undefined,
            expiredAt: row.expiredAt ?? undefined,
            finishedAt: row.completedAt ?? undefined,
            startedAt: row.startedAt ?? undefined,
            delayedUntil: row.delayUntil ?? undefined,
            queuedAt: row.queuedAt ?? undefined,
            error: row.error ? createJsonErrorObject(row.error) : undefined,
            isTest: row.isTest,
            metadata,
        };
    }
}
function apiStatusFromRunStatus(status) {
    switch (status) {
        case "DELAYED": {
            return "DELAYED";
        }
        case "WAITING_FOR_DEPLOY": {
            return "WAITING_FOR_DEPLOY";
        }
        case "PENDING": {
            return "QUEUED";
        }
        case "PAUSED":
        case "WAITING_TO_RESUME": {
            return "FROZEN";
        }
        case "RETRYING_AFTER_FAILURE": {
            return "REATTEMPTING";
        }
        case "EXECUTING": {
            return "EXECUTING";
        }
        case "CANCELED": {
            return "CANCELED";
        }
        case "COMPLETED_SUCCESSFULLY": {
            return "COMPLETED";
        }
        case "SYSTEM_FAILURE": {
            return "SYSTEM_FAILURE";
        }
        case "INTERRUPTED": {
            return "INTERRUPTED";
        }
        case "CRASHED": {
            return "CRASHED";
        }
        case "COMPLETED_WITH_ERRORS": {
            return "FAILED";
        }
        case "EXPIRED": {
            return "EXPIRED";
        }
        default: {
            throw new Error(`Unknown status: ${status}`);
        }
    }
}
function safeParseJSON(data) {
    try {
        return JSON.parse(data);
    }
    catch (error) {
        return data;
    }
}
//# sourceMappingURL=runStream.js.map