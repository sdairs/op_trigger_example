"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskExecutor = void 0;
const api_1 = require("@opentelemetry/api");
const version_js_1 = require("../../version.js");
const errors_js_1 = require("../errors.js");
const index_js_1 = require("../index.js");
const index_js_2 = require("../otel/index.js");
const index_js_3 = require("../schemas/index.js");
const semanticInternalAttributes_js_1 = require("../semanticInternalAttributes.js");
const task_context_api_js_1 = require("../task-context-api.js");
const ioSerialization_js_1 = require("../utils/ioSerialization.js");
const retries_js_1 = require("../utils/retries.js");
class TaskExecutor {
    task;
    _tracingSDK;
    _tracer;
    _consoleInterceptor;
    _importedConfig;
    _handleErrorFn;
    constructor(task, options) {
        this.task = task;
        this._tracingSDK = options.tracingSDK;
        this._tracer = options.tracer;
        this._consoleInterceptor = options.consoleInterceptor;
        this._importedConfig = options.config;
        this._handleErrorFn = options.handleErrorFn;
    }
    async execute(execution, worker, traceContext, usage, signal) {
        const ctx = index_js_3.TaskRunContext.parse(execution);
        const attemptMessage = `Attempt ${execution.attempt.number}`;
        const originalPacket = {
            data: execution.run.payload,
            dataType: execution.run.payloadType,
        };
        task_context_api_js_1.taskContext.setGlobalTaskContext({
            ctx,
            worker,
        });
        if (execution.run.metadata) {
            index_js_1.runMetadata.enterWithMetadata(execution.run.metadata);
        }
        this._tracingSDK.asyncResourceDetector.resolveWithAttributes({
            ...task_context_api_js_1.taskContext.attributes,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.SDK_VERSION]: version_js_1.VERSION,
            [semanticInternalAttributes_js_1.SemanticInternalAttributes.SDK_LANGUAGE]: "typescript",
        });
        const result = await this._tracer.startActiveSpan(attemptMessage, async (span) => {
            return await this._consoleInterceptor.intercept(console, async () => {
                let parsedPayload;
                let initOutput;
                try {
                    const payloadPacket = await (0, ioSerialization_js_1.conditionallyImportPacket)(originalPacket, this._tracer);
                    parsedPayload = await (0, ioSerialization_js_1.parsePacket)(payloadPacket);
                }
                catch (inputError) {
                    (0, index_js_2.recordSpanException)(span, inputError);
                    return {
                        ok: false,
                        id: execution.run.id,
                        error: {
                            type: "INTERNAL_ERROR",
                            code: index_js_3.TaskRunErrorCodes.TASK_INPUT_ERROR,
                            message: inputError instanceof Error
                                ? `${inputError.name}: ${inputError.message}`
                                : typeof inputError === "string"
                                    ? inputError
                                    : undefined,
                            stackTrace: inputError instanceof Error ? inputError.stack : undefined,
                        },
                    };
                }
                try {
                    parsedPayload = await this.#parsePayload(parsedPayload);
                    if (execution.attempt.number === 1) {
                        await this.#callOnStartFunctions(parsedPayload, ctx, signal);
                    }
                    initOutput = await this.#callInitFunctions(parsedPayload, ctx, signal);
                    const output = await this.#callRun(parsedPayload, ctx, initOutput, signal);
                    await this.#callOnSuccessFunctions(parsedPayload, output, ctx, initOutput, signal);
                    try {
                        const stringifiedOutput = await (0, ioSerialization_js_1.stringifyIO)(output);
                        const finalOutput = await (0, ioSerialization_js_1.conditionallyExportPacket)(stringifiedOutput, `${execution.attempt.id}/output`, this._tracer);
                        const attributes = await (0, ioSerialization_js_1.createPacketAttributes)(finalOutput, semanticInternalAttributes_js_1.SemanticInternalAttributes.OUTPUT, semanticInternalAttributes_js_1.SemanticInternalAttributes.OUTPUT_TYPE);
                        if (attributes) {
                            span.setAttributes(attributes);
                        }
                        return {
                            ok: true,
                            id: execution.run.id,
                            output: finalOutput.data,
                            outputType: finalOutput.dataType,
                        };
                    }
                    catch (outputError) {
                        (0, index_js_2.recordSpanException)(span, outputError);
                        return {
                            ok: false,
                            id: execution.run.id,
                            error: {
                                type: "INTERNAL_ERROR",
                                code: index_js_3.TaskRunErrorCodes.TASK_OUTPUT_ERROR,
                                message: outputError instanceof Error
                                    ? outputError.message
                                    : typeof outputError === "string"
                                        ? outputError
                                        : undefined,
                            },
                        };
                    }
                }
                catch (runError) {
                    try {
                        const handleErrorResult = await this.#handleError(execution, runError, parsedPayload, ctx, initOutput, signal);
                        (0, index_js_2.recordSpanException)(span, handleErrorResult.error ?? runError);
                        if (handleErrorResult.status !== "retry") {
                            await this.#callOnFailureFunctions(parsedPayload, handleErrorResult.error ?? runError, ctx, initOutput, signal);
                        }
                        return {
                            id: execution.run.id,
                            ok: false,
                            error: (0, errors_js_1.sanitizeError)(handleErrorResult.error
                                ? (0, errors_js_1.parseError)(handleErrorResult.error)
                                : (0, errors_js_1.parseError)(runError)),
                            retry: handleErrorResult.status === "retry" ? handleErrorResult.retry : undefined,
                            skippedRetrying: handleErrorResult.status === "skipped",
                        };
                    }
                    catch (handleErrorError) {
                        (0, index_js_2.recordSpanException)(span, handleErrorError);
                        return {
                            ok: false,
                            id: execution.run.id,
                            error: {
                                type: "INTERNAL_ERROR",
                                code: index_js_3.TaskRunErrorCodes.HANDLE_ERROR_ERROR,
                                message: handleErrorError instanceof Error
                                    ? handleErrorError.message
                                    : typeof handleErrorError === "string"
                                        ? handleErrorError
                                        : undefined,
                            },
                        };
                    }
                }
                finally {
                    await this.#callTaskCleanup(parsedPayload, ctx, initOutput, signal);
                    await this.#blockForWaitUntil();
                }
            });
        }, {
            kind: api_1.SpanKind.CONSUMER,
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "attempt",
            },
        }, this._tracer.extractContext(traceContext), signal);
        return { result };
    }
    async #callRun(payload, ctx, init, signal) {
        const runFn = this.task.fns.run;
        const middlewareFn = this.task.fns.middleware;
        if (!runFn) {
            throw new Error("Task does not have a run function");
        }
        if (!middlewareFn) {
            return runFn(payload, { ctx, init, signal });
        }
        return middlewareFn(payload, {
            ctx,
            signal,
            next: async () => runFn(payload, { ctx, init, signal }),
        });
    }
    async #callInitFunctions(payload, ctx, signal) {
        await this.#callConfigInit(payload, ctx, signal);
        const initFn = this.task.fns.init;
        if (!initFn) {
            return {};
        }
        return this._tracer.startActiveSpan("init", async (span) => {
            return await initFn(payload, { ctx, signal });
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "function",
            },
        });
    }
    async #callConfigInit(payload, ctx, signal) {
        const initFn = this._importedConfig?.init;
        if (!initFn) {
            return {};
        }
        return this._tracer.startActiveSpan("config.init", async (span) => {
            return await initFn(payload, { ctx, signal });
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "function",
            },
        });
    }
    async #callOnSuccessFunctions(payload, output, ctx, initOutput, signal) {
        await this.#callOnSuccessFunction(this.task.fns.onSuccess, "task.onSuccess", payload, output, ctx, initOutput, signal);
        await this.#callOnSuccessFunction(this._importedConfig?.onSuccess, "config.onSuccess", payload, output, ctx, initOutput, signal);
    }
    async #callOnSuccessFunction(onSuccessFn, name, payload, output, ctx, initOutput, signal) {
        if (!onSuccessFn) {
            return;
        }
        try {
            await this._tracer.startActiveSpan(name, async (span) => {
                return await onSuccessFn(payload, output, { ctx, init: initOutput, signal });
            }, {
                attributes: {
                    [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "function",
                },
            });
        }
        catch {
            // Ignore errors from onSuccess functions
        }
    }
    async #callOnFailureFunctions(payload, error, ctx, initOutput, signal) {
        await this.#callOnFailureFunction(this.task.fns.onFailure, "task.onFailure", payload, error, ctx, initOutput, signal);
        await this.#callOnFailureFunction(this._importedConfig?.onFailure, "config.onFailure", payload, error, ctx, initOutput, signal);
    }
    async #callOnFailureFunction(onFailureFn, name, payload, error, ctx, initOutput, signal) {
        if (!onFailureFn) {
            return;
        }
        try {
            return await this._tracer.startActiveSpan(name, async (span) => {
                return await onFailureFn(payload, error, { ctx, init: initOutput, signal });
            }, {
                attributes: {
                    [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "function",
                },
            });
        }
        catch (e) {
            // Ignore errors from onFailure functions
        }
    }
    async #parsePayload(payload) {
        if (!this.task.fns.parsePayload) {
            return payload;
        }
        try {
            return await this.task.fns.parsePayload(payload);
        }
        catch (e) {
            throw new errors_js_1.TaskPayloadParsedError(e);
        }
    }
    async #callOnStartFunctions(payload, ctx, signal) {
        await this.#callOnStartFunction(this._importedConfig?.onStart, "config.onStart", payload, ctx, {}, signal);
        await this.#callOnStartFunction(this.task.fns.onStart, "task.onStart", payload, ctx, {}, signal);
    }
    async #callOnStartFunction(onStartFn, name, payload, ctx, initOutput, signal) {
        if (!onStartFn) {
            return;
        }
        try {
            await this._tracer.startActiveSpan(name, async (span) => {
                return await onStartFn(payload, { ctx, signal });
            }, {
                attributes: {
                    [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "function",
                },
            });
        }
        catch {
            // Ignore errors from onStart functions
        }
    }
    async #callTaskCleanup(payload, ctx, init, signal) {
        const cleanupFn = this.task.fns.cleanup;
        if (!cleanupFn) {
            return;
        }
        return this._tracer.startActiveSpan("cleanup", async (span) => {
            return await cleanupFn(payload, { ctx, init, signal });
        });
    }
    async #blockForWaitUntil() {
        if (!index_js_1.waitUntil.requiresResolving()) {
            return;
        }
        return this._tracer.startActiveSpan("waitUntil", async (span) => {
            return await index_js_1.waitUntil.blockUntilSettled(60_000);
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "clock",
            },
        });
    }
    async #handleError(execution, error, payload, ctx, init, signal) {
        const retriesConfig = this._importedConfig?.retries;
        const retry = this.task.retry ?? retriesConfig?.default;
        if (!retry) {
            return { status: "noop" };
        }
        if (error instanceof Error &&
            (error.name === "AbortTaskRunError" || error.name === "TaskPayloadParsedError")) {
            return { status: "skipped" };
        }
        if (execution.run.maxAttempts) {
            retry.maxAttempts = Math.max(execution.run.maxAttempts, 1);
        }
        let delay = (0, retries_js_1.calculateNextRetryDelay)(retry, execution.attempt.number);
        if (delay &&
            error instanceof Error &&
            error.name === "TriggerApiError" &&
            error.status === 429) {
            const rateLimitError = error;
            delay = rateLimitError.millisecondsUntilReset;
        }
        if (execution.environment.type === "DEVELOPMENT" &&
            typeof retriesConfig?.enabledInDev === "boolean" &&
            !retriesConfig.enabledInDev) {
            return { status: "skipped" };
        }
        return this._tracer.startActiveSpan("handleError()", async (span) => {
            const handleErrorResult = this.task.fns.handleError
                ? await this.task.fns.handleError(payload, error, {
                    ctx,
                    init,
                    retry,
                    retryDelayInMs: delay,
                    retryAt: delay ? new Date(Date.now() + delay) : undefined,
                    signal,
                })
                : this._importedConfig
                    ? await this._handleErrorFn?.(payload, error, {
                        ctx,
                        init,
                        retry,
                        retryDelayInMs: delay,
                        retryAt: delay ? new Date(Date.now() + delay) : undefined,
                        signal,
                    })
                    : undefined;
            // If handleErrorResult
            if (!handleErrorResult) {
                return typeof delay === "undefined"
                    ? { status: "noop" }
                    : { status: "retry", retry: { timestamp: Date.now() + delay, delay } };
            }
            if (handleErrorResult.skipRetrying) {
                return { status: "skipped", error: handleErrorResult.error };
            }
            if (typeof handleErrorResult.retryAt !== "undefined") {
                return {
                    status: "retry",
                    retry: {
                        timestamp: handleErrorResult.retryAt.getTime(),
                        delay: handleErrorResult.retryAt.getTime() - Date.now(),
                    },
                    error: handleErrorResult.error,
                };
            }
            if (typeof handleErrorResult.retryDelayInMs === "number") {
                return {
                    status: "retry",
                    retry: {
                        timestamp: Date.now() + handleErrorResult.retryDelayInMs,
                        delay: handleErrorResult.retryDelayInMs,
                    },
                    error: handleErrorResult.error,
                };
            }
            if (handleErrorResult.retry && typeof handleErrorResult.retry === "object") {
                const delay = (0, retries_js_1.calculateNextRetryDelay)(handleErrorResult.retry, execution.attempt.number);
                return typeof delay === "undefined"
                    ? { status: "noop", error: handleErrorResult.error }
                    : {
                        status: "retry",
                        retry: { timestamp: Date.now() + delay, delay },
                        error: handleErrorResult.error,
                    };
            }
            return { status: "noop", error: handleErrorResult.error };
        }, {
            attributes: {
                [semanticInternalAttributes_js_1.SemanticInternalAttributes.STYLE_ICON]: "exclamation-circle",
            },
        });
    }
}
exports.TaskExecutor = TaskExecutor;
//# sourceMappingURL=taskExecutor.js.map