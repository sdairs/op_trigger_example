import type { AnyRetrieveRunResult, AnyRunShape, ApiRequestOptions, InferRunTypes, ListProjectRunsQueryParams, ListRunsQueryParams, RescheduleRunRequestBody, RetrieveRunResult, RunShape, RealtimeRun, AnyRealtimeRun, RunSubscription, TaskRunShape, AnyBatchedRunHandle } from "@trigger.dev/core/v3";
import { ApiPromise, CanceledRunResponse, CursorPagePromise, ListRunResponseItem, ReplayRunResponse, RetrieveRunResponse } from "@trigger.dev/core/v3";
import { AnyRunHandle, AnyTask } from "./shared.js";
export type { AnyRetrieveRunResult, AnyRunShape, RetrieveRunResult, RunShape, TaskRunShape, RealtimeRun, AnyRealtimeRun, };
export declare const runs: {
    replay: typeof replayRun;
    cancel: typeof cancelRun;
    retrieve: typeof retrieveRun;
    list: typeof listRuns;
    reschedule: typeof rescheduleRun;
    poll: typeof poll;
    subscribeToRun: typeof subscribeToRun;
    subscribeToRunsWithTag: typeof subscribeToRunsWithTag;
    subscribeToBatch: typeof subscribeToRunsInBatch;
};
export type ListRunsItem = ListRunResponseItem;
declare function listRuns(projectRef: string, params?: ListProjectRunsQueryParams, requestOptions?: ApiRequestOptions): CursorPagePromise<typeof ListRunResponseItem>;
declare function listRuns(params?: ListRunsQueryParams, requestOptions?: ApiRequestOptions): CursorPagePromise<typeof ListRunResponseItem>;
type RunId<TRunId> = TRunId extends AnyRunHandle | AnyBatchedRunHandle ? TRunId : TRunId extends AnyTask ? string : TRunId extends string ? TRunId : never;
declare function retrieveRun<TRunId extends AnyRunHandle | AnyBatchedRunHandle | AnyTask | string>(runId: RunId<TRunId>, requestOptions?: ApiRequestOptions): ApiPromise<RetrieveRunResult<TRunId>>;
declare function replayRun(runId: string, requestOptions?: ApiRequestOptions): ApiPromise<ReplayRunResponse>;
declare function cancelRun(runId: string, requestOptions?: ApiRequestOptions): ApiPromise<CanceledRunResponse>;
declare function rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ApiRequestOptions): ApiPromise<RetrieveRunResponse>;
export type PollOptions = {
    pollIntervalMs?: number;
};
declare function poll<TRunId extends AnyRunHandle | AnyTask | string>(runId: RunId<TRunId>, options?: {
    pollIntervalMs?: number;
}, requestOptions?: ApiRequestOptions): Promise<{
    version?: string | undefined;
    status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
    id: string;
    metadata?: Record<string, any> | undefined;
    startedAt?: Date | undefined;
    error?: {
        message: string;
        name?: string | undefined;
        stackTrace?: string | undefined;
    } | undefined;
    idempotencyKey?: string | undefined;
    attempts: ({
        status: "PENDING" | "COMPLETED" | "CANCELED" | "EXECUTING" | "FAILED" | "PAUSED";
        id: string;
        updatedAt: Date;
        createdAt: Date;
        startedAt?: Date | undefined;
        completedAt?: Date | undefined;
        error?: {
            message: string;
            name?: string | undefined;
            stackTrace?: string | undefined;
        } | undefined;
    } | undefined)[];
    schedule?: {
        id: string;
        generator: {
            type: "CRON";
            description: string;
            expression: string;
        };
        externalId?: string | undefined;
        deduplicationKey?: string | undefined;
    } | undefined;
    updatedAt: Date;
    isTest: boolean;
    createdAt: Date;
    tags: string[];
    durationMs: number;
    costInCents: number;
    baseCostInCents: number;
    taskIdentifier: string;
    ttl?: string | undefined;
    payloadPresignedUrl?: string | undefined;
    outputPresignedUrl?: string | undefined;
    relatedRuns: {
        root?: {
            status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
            id: string;
            updatedAt: Date;
            isTest: boolean;
            createdAt: Date;
            tags: string[];
            durationMs: number;
            costInCents: number;
            baseCostInCents: number;
            taskIdentifier: string;
            depth: number;
            triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
            isQueued: boolean;
            isExecuting: boolean;
            isCompleted: boolean;
            isSuccess: boolean;
            isFailed: boolean;
            isCancelled: boolean;
            version?: string | undefined;
            metadata?: Record<string, any> | undefined;
            startedAt?: Date | undefined;
            idempotencyKey?: string | undefined;
            ttl?: string | undefined;
            batchId?: string | undefined;
            finishedAt?: Date | undefined;
            delayedUntil?: Date | undefined;
            expiredAt?: Date | undefined;
        } | undefined;
        parent?: {
            status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
            id: string;
            updatedAt: Date;
            isTest: boolean;
            createdAt: Date;
            tags: string[];
            durationMs: number;
            costInCents: number;
            baseCostInCents: number;
            taskIdentifier: string;
            depth: number;
            triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
            isQueued: boolean;
            isExecuting: boolean;
            isCompleted: boolean;
            isSuccess: boolean;
            isFailed: boolean;
            isCancelled: boolean;
            version?: string | undefined;
            metadata?: Record<string, any> | undefined;
            startedAt?: Date | undefined;
            idempotencyKey?: string | undefined;
            ttl?: string | undefined;
            batchId?: string | undefined;
            finishedAt?: Date | undefined;
            delayedUntil?: Date | undefined;
            expiredAt?: Date | undefined;
        } | undefined;
        children?: {
            status: "COMPLETED" | "CANCELED" | "QUEUED" | "TIMED_OUT" | "EXECUTING" | "WAITING_FOR_DEPLOY" | "REATTEMPTING" | "FROZEN" | "FAILED" | "CRASHED" | "INTERRUPTED" | "SYSTEM_FAILURE" | "DELAYED" | "EXPIRED";
            id: string;
            updatedAt: Date;
            isTest: boolean;
            createdAt: Date;
            tags: string[];
            durationMs: number;
            costInCents: number;
            baseCostInCents: number;
            taskIdentifier: string;
            depth: number;
            triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
            isQueued: boolean;
            isExecuting: boolean;
            isCompleted: boolean;
            isSuccess: boolean;
            isFailed: boolean;
            isCancelled: boolean;
            version?: string | undefined;
            metadata?: Record<string, any> | undefined;
            startedAt?: Date | undefined;
            idempotencyKey?: string | undefined;
            ttl?: string | undefined;
            batchId?: string | undefined;
            finishedAt?: Date | undefined;
            delayedUntil?: Date | undefined;
            expiredAt?: Date | undefined;
        }[] | undefined;
    };
    depth: number;
    triggerFunction: "trigger" | "batchTrigger" | "triggerAndWait" | "batchTriggerAndWait";
    batchId?: string | undefined;
    isQueued: boolean;
    isExecuting: boolean;
    isCompleted: boolean;
    isSuccess: boolean;
    isFailed: boolean;
    isCancelled: boolean;
    finishedAt?: Date | undefined;
    delayedUntil?: Date | undefined;
    expiredAt?: Date | undefined;
    attemptCount: number;
    output?: InferRunTypes<TRunId>["output"] | undefined;
    payload?: InferRunTypes<TRunId>["payload"] | undefined;
}>;
/**
 * Subscribes to real-time updates for a specific run.
 *
 * This function allows you to receive real-time updates whenever a run changes, including:
 * - Status changes in the run lifecycle
 * - Tag additions or removals
 * - Metadata updates
 *
 * @template TRunId - The type parameter extending AnyRunHandle, AnyTask, or string
 * @param {RunId<TRunId>} runId - The ID of the run to subscribe to. Can be a string ID, RunHandle, or Task
 * @returns {RunSubscription<InferRunTypes<TRunId>>} An async iterator that yields updated run objects
 *
 * @example
 * ```ts
 * // Subscribe using a run handle
 * const handle = await tasks.trigger("my-task", { some: "data" });
 * for await (const run of runs.subscribeToRun(handle.id)) {
 *   console.log("Run updated:", run);
 * }
 *
 * // Subscribe with type safety
 * for await (const run of runs.subscribeToRun<typeof myTask>(runId)) {
 *   console.log("Payload:", run.payload.some);
 *   if (run.output) {
 *     console.log("Output:", run.output);
 *   }
 * }
 * ```
 */
declare function subscribeToRun<TRunId extends AnyRunHandle | AnyTask | string>(runId: RunId<TRunId>): RunSubscription<InferRunTypes<TRunId>>;
/**
 * Subscribes to real-time updates for all runs that have specific tags.
 *
 * This function allows you to monitor multiple runs simultaneously by filtering on tags.
 * You'll receive updates whenever any run with the specified tag(s) changes.
 *
 * @template TTasks - The type parameter extending AnyTask for type-safe payload and output
 * @param {string | string[]} tag - A single tag or array of tags to filter runs
 * @returns {RunSubscription<InferRunTypes<TTasks>>} An async iterator that yields updated run objects
 *
 * @example
 * ```ts
 * // Subscribe to runs with a single tag
 * for await (const run of runs.subscribeToRunsWithTag("user:1234")) {
 *   console.log("Run updated:", run);
 * }
 *
 * // Subscribe with multiple tags and type safety
 * for await (const run of runs.subscribeToRunsWithTag<typeof myTask | typeof otherTask>(["tag1", "tag2"])) {
 *   switch (run.taskIdentifier) {
 *     case "my-task":
 *       console.log("MyTask output:", run.output.foo);
 *       break;
 *     case "other-task":
 *       console.log("OtherTask output:", run.output.bar);
 *       break;
 *   }
 * }
 * ```
 */
declare function subscribeToRunsWithTag<TTasks extends AnyTask>(tag: string | string[]): RunSubscription<InferRunTypes<TTasks>>;
/**
 * Subscribes to real-time updates for all runs within a specific batch.
 *
 * Use this function when you've triggered multiple runs using `batchTrigger` and want
 * to monitor all runs in that batch. You'll receive updates whenever any run in the batch changes.
 *
 * @template TTasks - The type parameter extending AnyTask for type-safe payload and output
 * @param {string} batchId - The ID of the batch to subscribe to
 * @returns {RunSubscription<InferRunTypes<TTasks>>} An async iterator that yields updated run objects
 *
 * @example
 * ```ts
 * // Subscribe to all runs in a batch
 * for await (const run of runs.subscribeToRunsInBatch("batch-123")) {
 *   console.log("Batch run updated:", run);
 * }
 *
 * // Subscribe with type safety
 * for await (const run of runs.subscribeToRunsInBatch<typeof myTask>("batch-123")) {
 *   console.log("Run payload:", run.payload);
 *   if (run.output) {
 *     console.log("Run output:", run.output);
 *   }
 * }
 * ```
 *
 * @note The run objects received will include standard fields like id, status, payload, output,
 * createdAt, updatedAt, tags, and more. See the Run object documentation for full details.
 */
declare function subscribeToRunsInBatch<TTasks extends AnyTask>(batchId: string): RunSubscription<InferRunTypes<TTasks>>;
