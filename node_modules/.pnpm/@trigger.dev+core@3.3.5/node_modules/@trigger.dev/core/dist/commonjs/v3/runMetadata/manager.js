"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardMetadataManager = void 0;
const path_1 = require("@jsonhero/path");
const lite_1 = require("dequal/lite");
const metadataStream_js_1 = require("./metadataStream.js");
const MAXIMUM_ACTIVE_STREAMS = 2;
const MAXIMUM_TOTAL_STREAMS = 5;
class StandardMetadataManager {
    apiClient;
    streamsBaseUrl;
    flushTimeoutId = null;
    hasChanges = false;
    store;
    // Add a Map to track active streams
    activeStreams = new Map();
    runId;
    constructor(apiClient, streamsBaseUrl) {
        this.apiClient = apiClient;
        this.streamsBaseUrl = streamsBaseUrl;
    }
    enterWithMetadata(metadata) {
        this.store = metadata ?? {};
    }
    current() {
        return this.store;
    }
    getKey(key) {
        return this.store?.[key];
    }
    setKey(key, value) {
        if (!this.runId) {
            return;
        }
        let nextStore = this.store
            ? structuredClone(this.store)
            : undefined;
        if (key.startsWith("$.")) {
            const path = new path_1.JSONHeroPath(key);
            path.set(nextStore, value);
        }
        else {
            nextStore = {
                ...(nextStore ?? {}),
                [key]: value,
            };
        }
        if (!nextStore) {
            return;
        }
        if (!(0, lite_1.dequal)(this.store, nextStore)) {
            this.hasChanges = true;
        }
        this.store = nextStore;
    }
    deleteKey(key) {
        if (!this.runId) {
            return;
        }
        const nextStore = { ...(this.store ?? {}) };
        delete nextStore[key];
        if (!(0, lite_1.dequal)(this.store, nextStore)) {
            this.hasChanges = true;
        }
        this.store = nextStore;
    }
    appendKey(key, value) {
        if (!this.runId) {
            return;
        }
        let nextStore = this.store
            ? structuredClone(this.store)
            : {};
        if (key.startsWith("$.")) {
            const path = new path_1.JSONHeroPath(key);
            const currentValue = path.first(nextStore);
            if (currentValue === undefined) {
                // Initialize as array with single item
                path.set(nextStore, [value]);
            }
            else if (Array.isArray(currentValue)) {
                // Append to existing array
                path.set(nextStore, [...currentValue, value]);
            }
            else {
                // Convert to array if not already
                path.set(nextStore, [currentValue, value]);
            }
        }
        else {
            const currentValue = nextStore[key];
            if (currentValue === undefined) {
                // Initialize as array with single item
                nextStore[key] = [value];
            }
            else if (Array.isArray(currentValue)) {
                // Append to existing array
                nextStore[key] = [...currentValue, value];
            }
            else {
                // Convert to array if not already
                nextStore[key] = [currentValue, value];
            }
        }
        if (!(0, lite_1.dequal)(this.store, nextStore)) {
            this.hasChanges = true;
        }
        this.store = nextStore;
    }
    removeFromKey(key, value) {
        if (!this.runId) {
            return;
        }
        let nextStore = this.store
            ? structuredClone(this.store)
            : {};
        if (key.startsWith("$.")) {
            const path = new path_1.JSONHeroPath(key);
            const currentValue = path.first(nextStore);
            if (Array.isArray(currentValue)) {
                // Remove the value from array using deep equality check
                const newArray = currentValue.filter((item) => !(0, lite_1.dequal)(item, value));
                path.set(nextStore, newArray);
            }
        }
        else {
            const currentValue = nextStore[key];
            if (Array.isArray(currentValue)) {
                // Remove the value from array using deep equality check
                nextStore[key] = currentValue.filter((item) => !(0, lite_1.dequal)(item, value));
            }
        }
        if (!(0, lite_1.dequal)(this.store, nextStore)) {
            this.hasChanges = true;
        }
        this.store = nextStore;
    }
    incrementKey(key, increment = 1) {
        if (!this.runId) {
            return;
        }
        let nextStore = this.store ? structuredClone(this.store) : {};
        let currentValue = key.startsWith("$.")
            ? new path_1.JSONHeroPath(key).first(nextStore)
            : nextStore[key];
        const newValue = (typeof currentValue === "number" ? currentValue : 0) + increment;
        if (key.startsWith("$.")) {
            new path_1.JSONHeroPath(key).set(nextStore, newValue);
        }
        else {
            nextStore[key] = newValue;
        }
        if (!(0, lite_1.dequal)(this.store, nextStore)) {
            this.hasChanges = true;
            this.store = nextStore;
        }
    }
    decrementKey(key, decrement = 1) {
        this.incrementKey(key, -decrement);
    }
    update(metadata) {
        if (!this.runId) {
            return;
        }
        if (!(0, lite_1.dequal)(this.store, metadata)) {
            this.hasChanges = true;
        }
        this.store = metadata;
    }
    async stream(key, value, signal) {
        const $value = value;
        if (!this.runId) {
            return $value;
        }
        // Check to make sure we haven't exceeded the max number of active streams
        if (this.activeStreams.size >= MAXIMUM_ACTIVE_STREAMS) {
            console.warn(`Exceeded the maximum number of active streams (${MAXIMUM_ACTIVE_STREAMS}). The "${key}" stream will be ignored.`);
            return $value;
        }
        // Check to make sure we haven't exceeded the max number of total streams
        const streams = (this.store?.$$streams ?? []);
        if (streams.length >= MAXIMUM_TOTAL_STREAMS) {
            console.warn(`Exceeded the maximum number of total streams (${MAXIMUM_TOTAL_STREAMS}). The "${key}" stream will be ignored.`);
            return $value;
        }
        try {
            // Add the key to the special stream metadata object
            this.appendKey(`$$streams`, key);
            await this.flush();
            const streamInstance = new metadataStream_js_1.MetadataStream({
                key,
                runId: this.runId,
                iterator: $value[Symbol.asyncIterator](),
                baseUrl: this.streamsBaseUrl,
                signal,
            });
            this.activeStreams.set(key, streamInstance);
            // Clean up when stream completes
            streamInstance.wait().finally(() => this.activeStreams.delete(key));
            return streamInstance;
        }
        catch (error) {
            // Clean up metadata key if stream creation fails
            this.removeFromKey(`$$streams`, key);
            throw error;
        }
    }
    hasActiveStreams() {
        return this.activeStreams.size > 0;
    }
    // Waits for all the streams to finish
    async waitForAllStreams(timeout = 60_000) {
        if (this.activeStreams.size === 0) {
            return;
        }
        const promises = Array.from(this.activeStreams.values()).map((stream) => stream.wait());
        try {
            await Promise.race([
                Promise.allSettled(promises),
                new Promise((resolve, _) => setTimeout(() => resolve(), timeout)),
            ]);
        }
        catch (error) {
            console.error("Error waiting for streams to finish:", error);
            // If we time out, abort all remaining streams
            for (const [key, promise] of this.activeStreams.entries()) {
                // We can add abort logic here if needed
                this.activeStreams.delete(key);
            }
            throw error;
        }
    }
    async flush(requestOptions) {
        if (!this.runId) {
            return;
        }
        if (!this.store) {
            return;
        }
        if (!this.hasChanges) {
            return;
        }
        try {
            this.hasChanges = false;
            await this.apiClient.updateRunMetadata(this.runId, { metadata: this.store }, requestOptions);
        }
        catch (error) {
            this.hasChanges = true;
            throw error;
        }
    }
    startPeriodicFlush(intervalMs = 1000) {
        const periodicFlush = async (intervalMs) => {
            try {
                await this.flush();
            }
            catch (error) {
                console.error("Failed to flush metadata", error);
                throw error;
            }
            finally {
                scheduleNext();
            }
        };
        const scheduleNext = () => {
            this.flushTimeoutId = setTimeout(() => periodicFlush(intervalMs), intervalMs);
        };
        scheduleNext();
    }
    stopPeriodicFlush() {
        if (this.flushTimeoutId) {
            clearTimeout(this.flushTimeoutId);
            this.flushTimeoutId = null;
        }
    }
}
exports.StandardMetadataManager = StandardMetadataManager;
//# sourceMappingURL=manager.js.map