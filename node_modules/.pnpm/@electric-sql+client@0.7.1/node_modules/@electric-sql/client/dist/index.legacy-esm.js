var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/parser.ts
var parseNumber = (value) => Number(value);
var parseBool = (value) => value === `true` || value === `t`;
var parseBigInt = (value) => BigInt(value);
var parseJson = (value) => JSON.parse(value);
var identityParser = (v) => v;
var defaultParser = {
  int2: parseNumber,
  int4: parseNumber,
  int8: parseBigInt,
  bool: parseBool,
  float4: parseNumber,
  float8: parseNumber,
  json: parseJson,
  jsonb: parseJson
};
function pgArrayParser(value, parser) {
  let i = 0;
  let char = null;
  let str = ``;
  let quoted = false;
  let last = 0;
  let p = void 0;
  function loop(x) {
    const xs = [];
    for (; i < x.length; i++) {
      char = x[i];
      if (quoted) {
        if (char === `\\`) {
          str += x[++i];
        } else if (char === `"`) {
          xs.push(parser ? parser(str) : str);
          str = ``;
          quoted = x[i + 1] === `"`;
          last = i + 2;
        } else {
          str += char;
        }
      } else if (char === `"`) {
        quoted = true;
      } else if (char === `{`) {
        last = ++i;
        xs.push(loop(x));
      } else if (char === `}`) {
        quoted = false;
        last < i && xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));
        last = i + 1;
        break;
      } else if (char === `,` && p !== `}` && p !== `"`) {
        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));
        last = i + 1;
      }
      p = char;
    }
    last < i && xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1));
    return xs;
  }
  return loop(value)[0];
}
var MessageParser = class {
  constructor(parser) {
    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);
  }
  parse(messages, schema) {
    return JSON.parse(messages, (key, value) => {
      if (key === `value` && typeof value === `object` && value !== null) {
        const row = value;
        Object.keys(row).forEach((key2) => {
          row[key2] = this.parseRow(key2, row[key2], schema);
        });
      }
      return value;
    });
  }
  // Parses the message values using the provided parser based on the schema information
  parseRow(key, value, schema) {
    var _b;
    const columnInfo = schema[key];
    if (!columnInfo) {
      return value;
    }
    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, ["type", "dims"]);
    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;
    const parser = makeNullableParser(typeParser, columnInfo, key);
    if (dimensions && dimensions > 0) {
      const nullablePgArrayParser = makeNullableParser(
        (value2, _) => pgArrayParser(value2, parser),
        columnInfo,
        key
      );
      return nullablePgArrayParser(value);
    }
    return parser(value, additionalInfo);
  }
};
function makeNullableParser(parser, columnInfo, columnName) {
  var _a;
  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);
  return (value) => {
    if (isPgNull(value)) {
      if (!isNullable) {
        throw new Error(`Column ${columnName != null ? columnName : `unknown`} is not nullable`);
      }
      return null;
    }
    return parser(value, columnInfo);
  };
}
function isPgNull(value) {
  return value === null || value === `NULL`;
}

// src/helpers.ts
function isChangeMessage(message) {
  return `key` in message;
}
function isControlMessage(message) {
  return !isChangeMessage(message);
}
function isUpToDateMessage(message) {
  return isControlMessage(message) && message.headers.control === `up-to-date`;
}

// src/error.ts
var FetchError = class _FetchError extends Error {
  constructor(status, text, json, headers, url, message) {
    super(
      message || `HTTP Error ${status} at ${url}: ${text != null ? text : JSON.stringify(json)}`
    );
    this.url = url;
    this.name = `FetchError`;
    this.status = status;
    this.text = text;
    this.json = json;
    this.headers = headers;
  }
  static async fromResponse(response, url) {
    const status = response.status;
    const headers = Object.fromEntries([...response.headers.entries()]);
    let text = void 0;
    let json = void 0;
    const contentType = response.headers.get(`content-type`);
    if (contentType && contentType.includes(`application/json`)) {
      json = await response.json();
    } else {
      text = await response.text();
    }
    return new _FetchError(status, text, json, headers, url);
  }
};
var FetchBackoffAbortError = class extends Error {
  constructor() {
    super(`Fetch with backoff aborted`);
  }
};

// src/constants.ts
var LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;
var SHAPE_HANDLE_HEADER = `electric-handle`;
var CHUNK_LAST_OFFSET_HEADER = `electric-offset`;
var SHAPE_SCHEMA_HEADER = `electric-schema`;
var CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;
var DATABASE_ID_QUERY_PARAM = `database_id`;
var COLUMNS_QUERY_PARAM = `columns`;
var LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;
var SHAPE_HANDLE_QUERY_PARAM = `handle`;
var LIVE_QUERY_PARAM = `live`;
var OFFSET_QUERY_PARAM = `offset`;
var TABLE_QUERY_PARAM = `table`;
var WHERE_QUERY_PARAM = `where`;
var REPLICA_PARAM = `replica`;

// src/fetch.ts
var HTTP_RETRY_STATUS_CODES = [429];
var BackoffDefaults = {
  initialDelay: 100,
  maxDelay: 1e4,
  multiplier: 1.3
};
function createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {
  const {
    initialDelay,
    maxDelay,
    multiplier,
    debug = false,
    onFailedAttempt
  } = backoffOptions;
  return async (...args) => {
    var _a;
    const url = args[0];
    const options = args[1];
    let delay = initialDelay;
    let attempt = 0;
    while (true) {
      try {
        const result = await fetchClient(...args);
        if (result.ok) return result;
        else throw await FetchError.fromResponse(result, url.toString());
      } catch (e) {
        onFailedAttempt == null ? void 0 : onFailedAttempt();
        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
          throw new FetchBackoffAbortError();
        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {
          throw e;
        } else {
          await new Promise((resolve) => setTimeout(resolve, delay));
          delay = Math.min(delay * multiplier, maxDelay);
          if (debug) {
            attempt++;
            console.log(`Retry attempt #${attempt} after ${delay}ms`);
          }
        }
      }
    }
  };
}
var ChunkPrefetchDefaults = {
  maxChunksToPrefetch: 2
};
function createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {
  const { maxChunksToPrefetch } = prefetchOptions;
  let prefetchQueue;
  const prefetchClient = async (...args) => {
    const url = args[0].toString();
    const prefetchedRequest = prefetchQueue == null ? void 0 : prefetchQueue.consume(...args);
    if (prefetchedRequest) {
      return prefetchedRequest;
    }
    prefetchQueue == null ? void 0 : prefetchQueue.abort();
    const response = await fetchClient(...args);
    const nextUrl = getNextChunkUrl(url, response);
    if (nextUrl) {
      prefetchQueue = new PrefetchQueue({
        fetchClient,
        maxPrefetchedRequests: maxChunksToPrefetch,
        url: nextUrl,
        requestInit: args[1]
      });
    }
    return response;
  };
  return prefetchClient;
}
var _fetchClient, _maxPrefetchedRequests, _prefetchQueue, _queueHeadUrl, _queueTailUrl, _PrefetchQueue_instances, prefetch_fn;
var PrefetchQueue = class {
  constructor(options) {
    __privateAdd(this, _PrefetchQueue_instances);
    __privateAdd(this, _fetchClient);
    __privateAdd(this, _maxPrefetchedRequests);
    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map());
    __privateAdd(this, _queueHeadUrl);
    __privateAdd(this, _queueTailUrl);
    var _a;
    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args) => fetch(...args));
    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);
    __privateSet(this, _queueHeadUrl, options.url.toString());
    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));
    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);
  }
  abort() {
    __privateGet(this, _prefetchQueue).forEach(([_, aborter]) => aborter.abort());
  }
  consume(...args) {
    var _a;
    const url = args[0].toString();
    const request = (_a = __privateGet(this, _prefetchQueue).get(url)) == null ? void 0 : _a[0];
    if (!request || url !== __privateGet(this, _queueHeadUrl)) return;
    __privateGet(this, _prefetchQueue).delete(url);
    request.then((response) => {
      const nextUrl = getNextChunkUrl(url, response);
      __privateSet(this, _queueHeadUrl, nextUrl);
      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {
        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args[1]);
      }
    }).catch(() => {
    });
    return request;
  }
};
_fetchClient = new WeakMap();
_maxPrefetchedRequests = new WeakMap();
_prefetchQueue = new WeakMap();
_queueHeadUrl = new WeakMap();
_queueTailUrl = new WeakMap();
_PrefetchQueue_instances = new WeakSet();
prefetch_fn = function(...args) {
  var _a, _b;
  const url = args[0].toString();
  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests)) return;
  const aborter = new AbortController();
  try {
    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_a = args[1]) != null ? _a : {}), {
      signal: chainAborter(aborter, (_b = args[1]) == null ? void 0 : _b.signal)
    }));
    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);
    request.then((response) => {
      if (!response.ok || aborter.signal.aborted) return;
      const nextUrl = getNextChunkUrl(url, response);
      if (!nextUrl || nextUrl === url) {
        __privateSet(this, _queueTailUrl, void 0);
        return;
      }
      __privateSet(this, _queueTailUrl, nextUrl);
      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args[1]);
    }).catch(() => {
    });
  } catch (_) {
  }
};
function getNextChunkUrl(url, res) {
  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);
  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);
  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);
  if (!shapeHandle || !lastOffset || isUpToDate) return;
  const nextUrl = new URL(url);
  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM)) return;
  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);
  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);
  return nextUrl.toString();
}
function chainAborter(aborter, sourceSignal) {
  if (!sourceSignal) return aborter.signal;
  if (sourceSignal.aborted) aborter.abort();
  else
    sourceSignal.addEventListener(`abort`, () => aborter.abort(), {
      once: true
    });
  return aborter.signal;
}

// src/client.ts
var _fetchClient2, _messageParser, _subscribers, _upToDateSubscribers, _lastOffset, _liveCacheBuster, _lastSyncedAt, _isUpToDate, _connected, _shapeHandle, _databaseId, _schema, _error, _replica, _ShapeStream_instances, publish_fn, sendErrorToSubscribers_fn, notifyUpToDateSubscribers_fn, sendErrorToUpToDateSubscribers_fn, reset_fn;
var _ShapeStream = class _ShapeStream {
  constructor(options) {
    __privateAdd(this, _ShapeStream_instances);
    __privateAdd(this, _fetchClient2);
    __privateAdd(this, _messageParser);
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map());
    __privateAdd(this, _upToDateSubscribers, /* @__PURE__ */ new Map());
    __privateAdd(this, _lastOffset);
    __privateAdd(this, _liveCacheBuster);
    // Seconds since our Electric Epoch 😎
    __privateAdd(this, _lastSyncedAt);
    // unix time
    __privateAdd(this, _isUpToDate, false);
    __privateAdd(this, _connected, false);
    __privateAdd(this, _shapeHandle);
    __privateAdd(this, _databaseId);
    __privateAdd(this, _schema);
    __privateAdd(this, _error);
    __privateAdd(this, _replica);
    var _a, _b, _c;
    validateOptions(options);
    this.options = __spreadValues({ subscribe: true }, options);
    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);
    __privateSet(this, _liveCacheBuster, ``);
    __privateSet(this, _shapeHandle, this.options.shapeHandle);
    __privateSet(this, _databaseId, this.options.databaseId);
    __privateSet(this, _messageParser, new MessageParser(options.parser));
    __privateSet(this, _replica, this.options.replica);
    const baseFetchClient = (_b = options.fetchClient) != null ? _b : (...args) => fetch(...args);
    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, __spreadProps(__spreadValues({}, (_c = options.backoffOptions) != null ? _c : BackoffDefaults), {
      onFailedAttempt: () => {
        var _a2, _b2;
        __privateSet(this, _connected, false);
        (_b2 = (_a2 = options.backoffOptions) == null ? void 0 : _a2.onFailedAttempt) == null ? void 0 : _b2.call(_a2);
      }
    }));
    __privateSet(this, _fetchClient2, createFetchWithChunkBuffer(fetchWithBackoffClient));
    this.start();
  }
  get shapeHandle() {
    return __privateGet(this, _shapeHandle);
  }
  get isUpToDate() {
    return __privateGet(this, _isUpToDate);
  }
  get error() {
    return __privateGet(this, _error);
  }
  async start() {
    var _a, _b;
    __privateSet(this, _isUpToDate, false);
    const { url, table, where, columns, signal } = this.options;
    try {
      while (!(signal == null ? void 0 : signal.aborted) && !__privateGet(this, _isUpToDate) || this.options.subscribe) {
        const fetchUrl = new URL(url);
        if (table) fetchUrl.searchParams.set(TABLE_QUERY_PARAM, table);
        if (where) fetchUrl.searchParams.set(WHERE_QUERY_PARAM, where);
        if (columns && columns.length > 0)
          fetchUrl.searchParams.set(COLUMNS_QUERY_PARAM, columns.join(`,`));
        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));
        if (__privateGet(this, _isUpToDate)) {
          fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);
          fetchUrl.searchParams.set(
            LIVE_CACHE_BUSTER_QUERY_PARAM,
            __privateGet(this, _liveCacheBuster)
          );
        }
        if (__privateGet(this, _shapeHandle)) {
          fetchUrl.searchParams.set(
            SHAPE_HANDLE_QUERY_PARAM,
            __privateGet(this, _shapeHandle)
          );
        }
        if (__privateGet(this, _databaseId)) {
          fetchUrl.searchParams.set(DATABASE_ID_QUERY_PARAM, __privateGet(this, _databaseId));
        }
        if (((_a = __privateGet(this, _replica)) != null ? _a : _ShapeStream.Replica.DEFAULT) != _ShapeStream.Replica.DEFAULT) {
          fetchUrl.searchParams.set(REPLICA_PARAM, __privateGet(this, _replica));
        }
        let response;
        try {
          response = await __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
            signal,
            headers: this.options.headers
          });
          __privateSet(this, _connected, true);
        } catch (e) {
          if (e instanceof FetchBackoffAbortError) break;
          if (!(e instanceof FetchError)) throw e;
          if (e.status == 409) {
            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER];
            __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);
            await __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, e.json);
            continue;
          } else if (e.status >= 400 && e.status < 500) {
            __privateMethod(this, _ShapeStream_instances, sendErrorToUpToDateSubscribers_fn).call(this, e);
            __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, e);
            throw e;
          }
        }
        const { headers, status } = response;
        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);
        if (shapeHandle) {
          __privateSet(this, _shapeHandle, shapeHandle);
        }
        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);
        if (lastOffset) {
          __privateSet(this, _lastOffset, lastOffset);
        }
        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);
        if (liveCacheBuster) {
          __privateSet(this, _liveCacheBuster, liveCacheBuster);
        }
        const getSchema = () => {
          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);
          return schemaHeader ? JSON.parse(schemaHeader) : {};
        };
        __privateSet(this, _schema, (_b = __privateGet(this, _schema)) != null ? _b : getSchema());
        const messages = status === 204 ? `[]` : await response.text();
        if (status === 204) {
          __privateSet(this, _lastSyncedAt, Date.now());
        }
        const batch = __privateGet(this, _messageParser).parse(messages, __privateGet(this, _schema));
        if (batch.length > 0) {
          const prevUpToDate = __privateGet(this, _isUpToDate);
          const lastMessage = batch[batch.length - 1];
          if (isUpToDateMessage(lastMessage)) {
            __privateSet(this, _lastSyncedAt, Date.now());
            __privateSet(this, _isUpToDate, true);
          }
          await __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, batch);
          if (!prevUpToDate && __privateGet(this, _isUpToDate)) {
            __privateMethod(this, _ShapeStream_instances, notifyUpToDateSubscribers_fn).call(this);
          }
        }
      }
    } catch (err) {
      __privateSet(this, _error, err);
    } finally {
      __privateSet(this, _connected, false);
    }
  }
  subscribe(callback, onError) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);
    return () => {
      __privateGet(this, _subscribers).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    __privateGet(this, _subscribers).clear();
  }
  subscribeOnceToUpToDate(callback, error) {
    const subscriptionId = Math.random();
    __privateGet(this, _upToDateSubscribers).set(subscriptionId, [callback, error]);
    return () => {
      __privateGet(this, _upToDateSubscribers).delete(subscriptionId);
    };
  }
  unsubscribeAllUpToDateSubscribers() {
    __privateGet(this, _upToDateSubscribers).clear();
  }
  /** Unix time at which we last synced. Undefined when `isLoading` is true. */
  lastSyncedAt() {
    return __privateGet(this, _lastSyncedAt);
  }
  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */
  lastSynced() {
    if (__privateGet(this, _lastSyncedAt) === void 0) return Infinity;
    return Date.now() - __privateGet(this, _lastSyncedAt);
  }
  /** Indicates if we are connected to the Electric sync service. */
  isConnected() {
    return __privateGet(this, _connected);
  }
  /** True during initial fetch. False afterwise.  */
  isLoading() {
    return !this.isUpToDate;
  }
};
_fetchClient2 = new WeakMap();
_messageParser = new WeakMap();
_subscribers = new WeakMap();
_upToDateSubscribers = new WeakMap();
_lastOffset = new WeakMap();
_liveCacheBuster = new WeakMap();
_lastSyncedAt = new WeakMap();
_isUpToDate = new WeakMap();
_connected = new WeakMap();
_shapeHandle = new WeakMap();
_databaseId = new WeakMap();
_schema = new WeakMap();
_error = new WeakMap();
_replica = new WeakMap();
_ShapeStream_instances = new WeakSet();
publish_fn = async function(messages) {
  await Promise.all(
    Array.from(__privateGet(this, _subscribers).values()).map(async ([callback, __]) => {
      try {
        await callback(messages);
      } catch (err) {
        queueMicrotask(() => {
          throw err;
        });
      }
    })
  );
};
sendErrorToSubscribers_fn = function(error) {
  __privateGet(this, _subscribers).forEach(([_, errorFn]) => {
    errorFn == null ? void 0 : errorFn(error);
  });
};
notifyUpToDateSubscribers_fn = function() {
  __privateGet(this, _upToDateSubscribers).forEach(([callback]) => {
    callback();
  });
};
sendErrorToUpToDateSubscribers_fn = function(error) {
  __privateGet(this, _upToDateSubscribers).forEach(
    ([_, errorCallback]) => errorCallback(error)
  );
};
/**
 * Resets the state of the stream, optionally with a provided
 * shape handle
 */
reset_fn = function(shapeHandle) {
  __privateSet(this, _lastOffset, `-1`);
  __privateSet(this, _liveCacheBuster, ``);
  __privateSet(this, _shapeHandle, shapeHandle);
  __privateSet(this, _isUpToDate, false);
  __privateSet(this, _connected, false);
  __privateSet(this, _schema, void 0);
};
_ShapeStream.Replica = {
  FULL: `full`,
  DEFAULT: `default`
};
var ShapeStream = _ShapeStream;
function validateOptions(options) {
  if (!options.url) {
    throw new Error(`Invalid shape options. It must provide the url`);
  }
  if (options.signal && !(options.signal instanceof AbortSignal)) {
    throw new Error(
      `Invalid signal option. It must be an instance of AbortSignal.`
    );
  }
  if (options.offset !== void 0 && options.offset !== `-1` && !options.shapeHandle) {
    throw new Error(
      `shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`
    );
  }
  return;
}

// src/shape.ts
var _stream, _data, _subscribers2, _hasNotifiedSubscribersUpToDate, _error2, _Shape_instances, process_fn, handleError_fn, notify_fn;
var Shape = class {
  constructor(stream) {
    __privateAdd(this, _Shape_instances);
    __privateAdd(this, _stream);
    __privateAdd(this, _data, /* @__PURE__ */ new Map());
    __privateAdd(this, _subscribers2, /* @__PURE__ */ new Map());
    __privateAdd(this, _hasNotifiedSubscribersUpToDate, false);
    __privateAdd(this, _error2, false);
    __privateSet(this, _stream, stream);
    __privateGet(this, _stream).subscribe(
      __privateMethod(this, _Shape_instances, process_fn).bind(this),
      __privateMethod(this, _Shape_instances, handleError_fn).bind(this)
    );
    const unsubscribe = __privateGet(this, _stream).subscribeOnceToUpToDate(
      () => {
        unsubscribe();
      },
      (e) => {
        __privateMethod(this, _Shape_instances, handleError_fn).call(this, e);
        throw e;
      }
    );
  }
  get isUpToDate() {
    return __privateGet(this, _stream).isUpToDate;
  }
  get rows() {
    return this.value.then((v) => Array.from(v.values()));
  }
  get currentRows() {
    return Array.from(this.currentValue.values());
  }
  get value() {
    return new Promise((resolve, reject) => {
      if (__privateGet(this, _stream).isUpToDate) {
        resolve(this.currentValue);
      } else {
        const unsubscribe = this.subscribe(({ value }) => {
          unsubscribe();
          if (__privateGet(this, _error2)) reject(__privateGet(this, _error2));
          resolve(value);
        });
      }
    });
  }
  get currentValue() {
    return __privateGet(this, _data);
  }
  get error() {
    return __privateGet(this, _error2);
  }
  /** Unix time at which we last synced. Undefined when `isLoading` is true. */
  lastSyncedAt() {
    return __privateGet(this, _stream).lastSyncedAt();
  }
  /** Time elapsed since last sync (in ms). Infinity if we did not yet sync. */
  lastSynced() {
    return __privateGet(this, _stream).lastSynced();
  }
  /** True during initial fetch. False afterwise.  */
  isLoading() {
    return __privateGet(this, _stream).isLoading();
  }
  /** Indicates if we are connected to the Electric sync service. */
  isConnected() {
    return __privateGet(this, _stream).isConnected();
  }
  subscribe(callback) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers2).set(subscriptionId, callback);
    return () => {
      __privateGet(this, _subscribers2).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    __privateGet(this, _subscribers2).clear();
  }
  get numSubscribers() {
    return __privateGet(this, _subscribers2).size;
  }
};
_stream = new WeakMap();
_data = new WeakMap();
_subscribers2 = new WeakMap();
_hasNotifiedSubscribersUpToDate = new WeakMap();
_error2 = new WeakMap();
_Shape_instances = new WeakSet();
process_fn = function(messages) {
  let dataMayHaveChanged = false;
  let isUpToDate = false;
  let newlyUpToDate = false;
  messages.forEach((message) => {
    if (isChangeMessage(message)) {
      dataMayHaveChanged = [`insert`, `update`, `delete`].includes(
        message.headers.operation
      );
      switch (message.headers.operation) {
        case `insert`:
          __privateGet(this, _data).set(message.key, message.value);
          break;
        case `update`:
          __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
          break;
        case `delete`:
          __privateGet(this, _data).delete(message.key);
          break;
      }
    }
    if (isControlMessage(message)) {
      switch (message.headers.control) {
        case `up-to-date`:
          isUpToDate = true;
          if (!__privateGet(this, _hasNotifiedSubscribersUpToDate)) {
            newlyUpToDate = true;
          }
          break;
        case `must-refetch`:
          __privateGet(this, _data).clear();
          __privateSet(this, _error2, false);
          __privateSet(this, _hasNotifiedSubscribersUpToDate, false);
          isUpToDate = false;
          newlyUpToDate = false;
          break;
      }
    }
  });
  if (newlyUpToDate || isUpToDate && dataMayHaveChanged) {
    __privateSet(this, _hasNotifiedSubscribersUpToDate, true);
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
  }
};
handleError_fn = function(e) {
  if (e instanceof FetchError) {
    __privateSet(this, _error2, e);
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
  }
};
notify_fn = function() {
  __privateGet(this, _subscribers2).forEach((callback) => {
    callback({ value: this.currentValue, rows: this.currentRows });
  });
};
export {
  BackoffDefaults,
  FetchError,
  Shape,
  ShapeStream,
  isChangeMessage,
  isControlMessage
};
//# sourceMappingURL=index.legacy-esm.js.map