"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runs = void 0;
const v3_1 = require("@trigger.dev/core/v3");
const ioSerialization_1 = require("@trigger.dev/core/v3/utils/ioSerialization");
const tracer_js_1 = require("./tracer.js");
exports.runs = {
    replay: replayRun,
    cancel: cancelRun,
    retrieve: retrieveRun,
    list: listRuns,
    reschedule: rescheduleRun,
    poll,
    subscribeToRun,
    subscribeToRunsWithTag,
    subscribeToBatch: subscribeToRunsInBatch,
};
function listRuns(paramsOrProjectRef, paramsOrOptions, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions);
    if (typeof paramsOrProjectRef === "string") {
        if ((0, v3_1.isRequestOptions)(paramsOrOptions)) {
            return apiClient.listProjectRuns(paramsOrProjectRef, {}, $requestOptions);
        }
        else {
            return apiClient.listProjectRuns(paramsOrProjectRef, paramsOrOptions, $requestOptions);
        }
    }
    return apiClient.listRuns(paramsOrProjectRef, $requestOptions);
}
function listRunsRequestOptions(paramsOrProjectRef, paramsOrOptions, requestOptions) {
    if (typeof paramsOrProjectRef === "string") {
        if ((0, v3_1.isRequestOptions)(paramsOrOptions)) {
            return (0, v3_1.mergeRequestOptions)({
                tracer: tracer_js_1.tracer,
                name: "runs.list()",
                icon: "runs",
                attributes: {
                    projectRef: paramsOrProjectRef,
                    ...(0, v3_1.accessoryAttributes)({
                        items: [
                            {
                                text: paramsOrProjectRef,
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            }, paramsOrOptions);
        }
        else {
            return (0, v3_1.mergeRequestOptions)({
                tracer: tracer_js_1.tracer,
                name: "runs.list()",
                icon: "runs",
                attributes: {
                    projectRef: paramsOrProjectRef,
                    ...(0, v3_1.flattenAttributes)(paramsOrOptions, "queryParams"),
                    ...(0, v3_1.accessoryAttributes)({
                        items: [
                            {
                                text: paramsOrProjectRef,
                                variant: "normal",
                            },
                        ],
                        style: "codepath",
                    }),
                },
            }, requestOptions);
        }
    }
    return (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.list()",
        icon: "runs",
        attributes: {
            ...(0, v3_1.flattenAttributes)(paramsOrProjectRef, "queryParams"),
        },
    }, (0, v3_1.isRequestOptions)(paramsOrOptions) ? paramsOrOptions : requestOptions);
}
function retrieveRun(runId, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.retrieve()",
        icon: "runs",
        attributes: {
            runId: typeof runId === "string" ? runId : runId.id,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: typeof runId === "string" ? runId : runId.id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    const $runId = typeof runId === "string" ? runId : runId.id;
    return apiClient.retrieveRun($runId, $requestOptions).then((retrievedRun) => {
        return resolvePayloadAndOutputUrls(retrievedRun);
    });
}
async function resolvePayloadAndOutputUrls(run) {
    const resolvedRun = { ...run };
    if (run.payloadPresignedUrl && run.outputPresignedUrl) {
        const [payload, output] = await Promise.all([
            (0, ioSerialization_1.resolvePresignedPacketUrl)(run.payloadPresignedUrl, tracer_js_1.tracer),
            (0, ioSerialization_1.resolvePresignedPacketUrl)(run.outputPresignedUrl, tracer_js_1.tracer),
        ]);
        resolvedRun.payload = payload;
        resolvedRun.output = output;
    }
    else if (run.payloadPresignedUrl) {
        resolvedRun.payload = await (0, ioSerialization_1.resolvePresignedPacketUrl)(run.payloadPresignedUrl, tracer_js_1.tracer);
    }
    else if (run.outputPresignedUrl) {
        resolvedRun.output = await (0, ioSerialization_1.resolvePresignedPacketUrl)(run.outputPresignedUrl, tracer_js_1.tracer);
    }
    return resolvedRun;
}
function replayRun(runId, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.replay()",
        icon: "runs",
        attributes: {
            runId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.replayRun(runId, $requestOptions);
}
function cancelRun(runId, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.cancel()",
        icon: "runs",
        attributes: {
            runId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.cancelRun(runId, $requestOptions);
}
function rescheduleRun(runId, body, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const $requestOptions = (0, v3_1.mergeRequestOptions)({
        tracer: tracer_js_1.tracer,
        name: "runs.reschedule()",
        icon: "runs",
        attributes: {
            runId,
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: runId,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    }, requestOptions);
    return apiClient.rescheduleRun(runId, body, $requestOptions);
}
const MAX_POLL_ATTEMPTS = 500;
async function poll(runId, options, requestOptions) {
    let attempts = 0;
    while (attempts++ < MAX_POLL_ATTEMPTS) {
        const run = await exports.runs.retrieve(runId, requestOptions);
        if (run.isCompleted) {
            return run;
        }
        await new Promise((resolve) => setTimeout(resolve, options?.pollIntervalMs ?? 1000));
    }
    throw new Error(`Run ${typeof runId === "string" ? runId : runId.id} did not complete after ${MAX_POLL_ATTEMPTS} attempts`);
}
/**
 * Subscribes to real-time updates for a specific run.
 *
 * This function allows you to receive real-time updates whenever a run changes, including:
 * - Status changes in the run lifecycle
 * - Tag additions or removals
 * - Metadata updates
 *
 * @template TRunId - The type parameter extending AnyRunHandle, AnyTask, or string
 * @param {RunId<TRunId>} runId - The ID of the run to subscribe to. Can be a string ID, RunHandle, or Task
 * @returns {RunSubscription<InferRunTypes<TRunId>>} An async iterator that yields updated run objects
 *
 * @example
 * ```ts
 * // Subscribe using a run handle
 * const handle = await tasks.trigger("my-task", { some: "data" });
 * for await (const run of runs.subscribeToRun(handle.id)) {
 *   console.log("Run updated:", run);
 * }
 *
 * // Subscribe with type safety
 * for await (const run of runs.subscribeToRun<typeof myTask>(runId)) {
 *   console.log("Payload:", run.payload.some);
 *   if (run.output) {
 *     console.log("Output:", run.output);
 *   }
 * }
 * ```
 */
function subscribeToRun(runId) {
    const $runId = typeof runId === "string" ? runId : runId.id;
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return apiClient.subscribeToRun($runId);
}
/**
 * Subscribes to real-time updates for all runs that have specific tags.
 *
 * This function allows you to monitor multiple runs simultaneously by filtering on tags.
 * You'll receive updates whenever any run with the specified tag(s) changes.
 *
 * @template TTasks - The type parameter extending AnyTask for type-safe payload and output
 * @param {string | string[]} tag - A single tag or array of tags to filter runs
 * @returns {RunSubscription<InferRunTypes<TTasks>>} An async iterator that yields updated run objects
 *
 * @example
 * ```ts
 * // Subscribe to runs with a single tag
 * for await (const run of runs.subscribeToRunsWithTag("user:1234")) {
 *   console.log("Run updated:", run);
 * }
 *
 * // Subscribe with multiple tags and type safety
 * for await (const run of runs.subscribeToRunsWithTag<typeof myTask | typeof otherTask>(["tag1", "tag2"])) {
 *   switch (run.taskIdentifier) {
 *     case "my-task":
 *       console.log("MyTask output:", run.output.foo);
 *       break;
 *     case "other-task":
 *       console.log("OtherTask output:", run.output.bar);
 *       break;
 *   }
 * }
 * ```
 */
function subscribeToRunsWithTag(tag) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return apiClient.subscribeToRunsWithTag(tag);
}
/**
 * Subscribes to real-time updates for all runs within a specific batch.
 *
 * Use this function when you've triggered multiple runs using `batchTrigger` and want
 * to monitor all runs in that batch. You'll receive updates whenever any run in the batch changes.
 *
 * @template TTasks - The type parameter extending AnyTask for type-safe payload and output
 * @param {string} batchId - The ID of the batch to subscribe to
 * @returns {RunSubscription<InferRunTypes<TTasks>>} An async iterator that yields updated run objects
 *
 * @example
 * ```ts
 * // Subscribe to all runs in a batch
 * for await (const run of runs.subscribeToRunsInBatch("batch-123")) {
 *   console.log("Batch run updated:", run);
 * }
 *
 * // Subscribe with type safety
 * for await (const run of runs.subscribeToRunsInBatch<typeof myTask>("batch-123")) {
 *   console.log("Run payload:", run.payload);
 *   if (run.output) {
 *     console.log("Run output:", run.output);
 *   }
 * }
 * ```
 *
 * @note The run objects received will include standard fields like id, status, payload, output,
 * createdAt, updatedAt, tags, and more. See the Run object documentation for full details.
 */
function subscribeToRunsInBatch(batchId) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return apiClient.subscribeToBatch(batchId);
}
//# sourceMappingURL=runs.js.map