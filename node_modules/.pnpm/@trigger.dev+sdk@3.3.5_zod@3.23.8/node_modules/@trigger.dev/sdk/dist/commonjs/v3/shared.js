"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRunPromise = exports.SubtaskUnwrapError = void 0;
exports.queue = queue;
exports.createTask = createTask;
exports.createToolTask = createToolTask;
exports.createSchemaTask = createSchemaTask;
exports.trigger = trigger;
exports.triggerAndWait = triggerAndWait;
exports.batchTriggerAndWait = batchTriggerAndWait;
exports.triggerAndPoll = triggerAndPoll;
exports.batchTrigger = batchTrigger;
exports.batchTriggerById = batchTriggerById;
exports.batchTriggerByIdAndWait = batchTriggerByIdAndWait;
exports.batchTriggerTasks = batchTriggerTasks;
exports.batchTriggerAndWaitTasks = batchTriggerAndWaitTasks;
const api_1 = require("@opentelemetry/api");
const v3_1 = require("@trigger.dev/core/v3");
Object.defineProperty(exports, "SubtaskUnwrapError", { enumerable: true, get: function () { return v3_1.SubtaskUnwrapError; } });
Object.defineProperty(exports, "TaskRunPromise", { enumerable: true, get: function () { return v3_1.TaskRunPromise; } });
const runs_js_1 = require("./runs.js");
const tracer_js_1 = require("./tracer.js");
function queue(options) {
    return options;
}
function createTask(params) {
    const customQueue = params.queue
        ? queue({
            name: params.queue?.name ?? `task/${params.id}`,
            ...params.queue,
        })
        : undefined;
    const task = {
        id: params.id,
        description: params.description,
        trigger: async (payload, options) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await trigger_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.trigger()`
                : `trigger()`, params.id, payload, undefined, {
                queue: customQueue,
                ...options,
            });
        },
        batchTrigger: async (items, options) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await batchTrigger_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.batchTrigger()`
                : `batchTrigger()`, params.id, items, options, undefined, undefined, customQueue);
        },
        triggerAndWait: (payload, options) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return new v3_1.TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal(taskMetadata && taskMetadata.exportName
                    ? `${taskMetadata.exportName}.triggerAndWait()`
                    : `triggerAndWait()`, params.id, payload, undefined, {
                    queue: customQueue,
                    ...options,
                })
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await batchTriggerAndWait_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.batchTriggerAndWait()`
                : `batchTriggerAndWait()`, params.id, items, undefined, undefined, customQueue);
        },
    };
    v3_1.taskCatalog.registerTaskMetadata({
        id: params.id,
        description: params.description,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: params.machine,
        maxDuration: params.maxDuration,
        fns: {
            run: params.run,
            init: params.init,
            cleanup: params.cleanup,
            middleware: params.middleware,
            handleError: params.handleError,
            onSuccess: params.onSuccess,
            onFailure: params.onFailure,
            onStart: params.onStart,
        },
    });
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
function createToolTask(params) {
    const task = createSchemaTask({
        ...params,
        schema: (0, v3_1.convertToolParametersToSchema)(params.parameters),
    });
    return {
        ...task,
        tool: {
            parameters: params.parameters,
            description: params.description,
            execute: async (args) => {
                return task.triggerAndWait(args).unwrap();
            },
        },
    };
}
function createSchemaTask(params) {
    const customQueue = params.queue
        ? queue({
            name: params.queue?.name ?? `task/${params.id}`,
            ...params.queue,
        })
        : undefined;
    const parsePayload = params.schema
        ? (0, v3_1.getSchemaParseFn)(params.schema)
        : undefined;
    const task = {
        id: params.id,
        description: params.description,
        schema: params.schema,
        trigger: async (payload, options, requestOptions) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await trigger_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.trigger()`
                : `trigger()`, params.id, payload, parsePayload, {
                queue: customQueue,
                ...options,
            }, requestOptions);
        },
        batchTrigger: async (items, options, requestOptions) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await batchTrigger_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.batchTrigger()`
                : `batchTrigger()`, params.id, items, options, parsePayload, requestOptions, customQueue);
        },
        triggerAndWait: (payload, options) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return new v3_1.TaskRunPromise((resolve, reject) => {
                triggerAndWait_internal(taskMetadata && taskMetadata.exportName
                    ? `${taskMetadata.exportName}.triggerAndWait()`
                    : `triggerAndWait()`, params.id, payload, parsePayload, {
                    queue: customQueue,
                    ...options,
                })
                    .then((result) => {
                    resolve(result);
                })
                    .catch((error) => {
                    reject(error);
                });
            }, params.id);
        },
        batchTriggerAndWait: async (items) => {
            const taskMetadata = v3_1.taskCatalog.getTaskManifest(params.id);
            return await batchTriggerAndWait_internal(taskMetadata && taskMetadata.exportName
                ? `${taskMetadata.exportName}.batchTriggerAndWait()`
                : `batchTriggerAndWait()`, params.id, items, parsePayload, undefined, customQueue);
        },
    };
    v3_1.taskCatalog.registerTaskMetadata({
        id: params.id,
        description: params.description,
        queue: params.queue,
        retry: params.retry ? { ...v3_1.defaultRetryOptions, ...params.retry } : undefined,
        machine: params.machine,
        maxDuration: params.maxDuration,
        fns: {
            run: params.run,
            init: params.init,
            cleanup: params.cleanup,
            middleware: params.middleware,
            handleError: params.handleError,
            onSuccess: params.onSuccess,
            onFailure: params.onFailure,
            onStart: params.onStart,
            parsePayload,
        },
    });
    // @ts-expect-error
    task[Symbol.for("trigger.dev/task")] = true;
    return task;
}
/**
 * Trigger a task by its identifier with the given payload. Returns a typesafe `RunHandle`.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const handle = await tasks.trigger<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * const run = await runs.retrieve(handle);
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {RunHandle} An object with the `id` of the run. Can be used to retrieve the completed run output in a typesafe manner.
 */
async function trigger(id, payload, options, requestOptions) {
    return await trigger_internal("tasks.trigger()", id, payload, undefined, options, requestOptions);
}
/**
 * Trigger a task with the given payload, and wait for the result. Returns the result of the task run
 * @param id - The id of the task to trigger
 * @param payload
 * @param options - Options for the task run
 * @returns TaskRunResult
 * @example
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 * const result = await tasks.triggerAndWait("my-task", { foo: "bar" });
 *
 * if (result.ok) {
 *  console.log(result.output);
 * } else {
 *  console.error(result.error);
 * }
 * ```
 */
function triggerAndWait(id, payload, options, requestOptions) {
    return new v3_1.TaskRunPromise((resolve, reject) => {
        triggerAndWait_internal("tasks.triggerAndWait()", id, payload, undefined, options, requestOptions)
            .then((result) => {
            resolve(result);
        })
            .catch((error) => {
            reject(error);
        });
    }, id);
}
/**
 * Batch trigger multiple task runs with the given payloads, and wait for the results. Returns the results of the task runs.
 * @param id - The id of the task to trigger
 * @param items
 * @returns BatchResult
 * @example
 *
 * ```ts
 * import { tasks } from "@trigger.dev/sdk/v3";
 *
 * const result = await tasks.batchTriggerAndWait("my-task", [
 *  { payload: { foo: "bar" } },
 *  { payload: { foo: "baz" } },
 * ]);
 *
 * for (const run of result.runs) {
 *  if (run.ok) {
 *    console.log(run.output);
 *  } else {
 *    console.error(run.error);
 *  }
 * }
 * ```
 */
async function batchTriggerAndWait(id, items, requestOptions) {
    return await batchTriggerAndWait_internal("tasks.batchTriggerAndWait()", id, items, undefined, requestOptions);
}
/**
 * Trigger a task by its identifier with the given payload and poll until the run is completed.
 *
 * @example
 *
 * ```ts
 * import { tasks, runs } from "@trigger.dev/sdk/v3";
 * import type { myTask } from "./myTasks"; // Import just the type of the task
 *
 * const run = await tasks.triggerAndPoll<typeof myTask>("my-task", { foo: "bar" }); // The id and payload are fully typesafe
 * console.log(run.output) // The output is also fully typed
 * ```
 *
 * @returns {Run} The completed run, either successful or failed.
 */
async function triggerAndPoll(id, payload, options, requestOptions) {
    const handle = await trigger(id, payload, options, requestOptions);
    return runs_js_1.runs.poll(handle, options, requestOptions);
}
async function batchTrigger(id, items, options, requestOptions) {
    return await batchTrigger_internal("tasks.batchTrigger()", id, items, options, undefined, requestOptions);
}
/**
 * Triggers multiple runs of different tasks with specified payloads and options.
 *
 * @template TTask - The type of task(s) to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {BatchTriggerOptions} [options] - Optional batch-level trigger options
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchRunHandleFromTypes<InferRunTypes<TTask>>>} A promise that resolves with the batch run handle
 * containing batch ID, cached status, idempotency info, runs, and public access token
 *
 * @example
 * ```ts
 * import { batch } from "@trigger.dev/sdk/v3";
 * import type { myTask1, myTask2 } from "~/trigger/myTasks";
 *
 * // Trigger multiple tasks with different payloads
 * const result = await batch.trigger<typeof myTask1 | typeof myTask2>([
 *   {
 *     id: "my-task-1",
 *     payload: { some: "data" },
 *     options: {
 *       queue: "default",
 *       concurrencyKey: "key",
 *       idempotencyKey: "unique-key",
 *       delay: "5m",
 *       tags: ["tag1", "tag2"]
 *     }
 *   },
 *   {
 *     id: "my-task-2",
 *     payload: { other: "data" }
 *   }
 * ]);
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The unique identifier of the task
 * - `payload`: The data to pass to the task
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `idempotencyKey`: Prevent duplicate runs
 *   - `idempotencyKeyTTL`: Time-to-live for idempotency key
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 */
async function batchTriggerById(items, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const response = await apiClient.batchTriggerV2({
        items: await Promise.all(items.map(async (item) => {
            const taskMetadata = v3_1.taskCatalog.getTask(item.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            return {
                task: item.id,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    idempotencyKey: await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey),
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    parentAttempt: v3_1.taskContext.ctx?.attempt.id,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                },
            };
        })),
    }, {
        spanParentAsLink: true,
        idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
        idempotencyKeyTTL: options?.idempotencyKeyTTL,
    }, {
        name: "batch.trigger()",
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody(body, span) {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("batchId", body.id);
                }
                if ("runs" in body && Array.isArray(body.runs)) {
                    span.setAttribute("runCount", body.runs.length);
                }
                if ("isCached" in body && typeof body.isCached === "boolean") {
                    if (body.isCached) {
                        console.warn(`Result is a cached response because the request was idempotent.`);
                    }
                    span.setAttribute("isCached", body.isCached);
                }
                if ("idempotencyKey" in body && typeof body.idempotencyKey === "string") {
                    span.setAttribute("idempotencyKey", body.idempotencyKey);
                }
            }
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.id,
        isCached: response.isCached,
        idempotencyKey: response.idempotencyKey,
        runs: response.runs,
        publicAccessToken: response.publicAccessToken,
    };
    return handle;
}
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 */
async function batchTriggerByIdAndWait(items, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return await tracer_js_1.tracer.startActiveSpan("batch.triggerAndWait()", async (span) => {
        const response = await apiClient.batchTriggerV2({
            items: await Promise.all(items.map(async (item) => {
                const taskMetadata = v3_1.taskCatalog.getTask(item.id);
                const parsedPayload = taskMetadata?.fns.parsePayload
                    ? await taskMetadata?.fns.parsePayload(item.payload)
                    : item.payload;
                const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
                return {
                    task: item.id,
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                        metadata: item.options?.metadata,
                        maxDuration: item.options?.maxDuration,
                    },
                };
            })),
            dependentAttempt: ctx.attempt.id,
        }, {}, requestOptions);
        span.setAttribute("batchId", response.id);
        span.setAttribute("runCount", response.runs.length);
        span.setAttribute("isCached", response.isCached);
        if (response.isCached) {
            console.warn(`Result is a cached response because the request was idempotent.`);
        }
        if (response.idempotencyKey) {
            span.setAttribute("idempotencyKey", response.idempotencyKey);
        }
        const result = await v3_1.runtime.waitForBatch({
            id: response.id,
            runs: response.runs.map((run) => run.id),
            ctx,
        });
        const runs = await handleBatchTaskRunExecutionResultV2(result.items);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
        },
    });
}
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 */
async function batchTriggerTasks(items, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const response = await apiClient.batchTriggerV2({
        items: await Promise.all(items.map(async (item) => {
            const taskMetadata = v3_1.taskCatalog.getTask(item.task.id);
            const parsedPayload = taskMetadata?.fns.parsePayload
                ? await taskMetadata?.fns.parsePayload(item.payload)
                : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            return {
                task: item.task.id,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    idempotencyKey: await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey),
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    parentAttempt: v3_1.taskContext.ctx?.attempt.id,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                },
            };
        })),
    }, {
        spanParentAsLink: true,
        idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
        idempotencyKeyTTL: options?.idempotencyKeyTTL,
    }, {
        name: "batch.triggerByTask()",
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody(body, span) {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("batchId", body.id);
                }
                if ("runs" in body && Array.isArray(body.runs)) {
                    span.setAttribute("runCount", body.runs.length);
                }
                if ("isCached" in body && typeof body.isCached === "boolean") {
                    if (body.isCached) {
                        console.warn(`Result is a cached response because the request was idempotent.`);
                    }
                    span.setAttribute("isCached", body.isCached);
                }
                if ("idempotencyKey" in body && typeof body.idempotencyKey === "string") {
                    span.setAttribute("idempotencyKey", body.idempotencyKey);
                }
            }
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.id,
        isCached: response.isCached,
        idempotencyKey: response.idempotencyKey,
        runs: response.runs,
        publicAccessToken: response.publicAccessToken,
    };
    return handle;
}
/**
 * Triggers multiple tasks and waits for all of them to complete before returning their results.
 * This function must be called from within a task.run() context.
 *
 * @template TTask - Union type of tasks to be triggered, extends AnyTask
 *
 * @param {Array<BatchByIdAndWaitItem<InferRunTypes<TTask>>>} items - Array of task items to trigger
 * @param {TriggerApiRequestOptions} [requestOptions] - Optional API request configuration
 *
 * @returns {Promise<BatchByIdResult<TTask>>} A promise that resolves with the batch results, including
 * success/failure status and strongly-typed outputs for each task
 *
 * @throws {Error} If called outside of a task.run() context
 * @throws {Error} If no API client is configured
 *
 * @example
 * ```ts
 * import { batch, task } from "@trigger.dev/sdk/v3";
 *
 * export const parentTask = task({
 *   id: "parent-task",
 *   run: async (payload: string) => {
 *     const results = await batch.triggerAndWait<typeof childTask1 | typeof childTask2>([
 *       {
 *         id: "child-task-1",
 *         payload: { foo: "World" },
 *         options: {
 *           queue: "default",
 *           delay: "5m",
 *           tags: ["batch", "child1"]
 *         }
 *       },
 *       {
 *         id: "child-task-2",
 *         payload: { bar: 42 }
 *       }
 *     ]);
 *
 *     // Type-safe result handling
 *     for (const result of results) {
 *       if (result.ok) {
 *         switch (result.taskIdentifier) {
 *           case "child-task-1":
 *             console.log("Child task 1 output:", result.output); // string type
 *             break;
 *           case "child-task-2":
 *             console.log("Child task 2 output:", result.output); // number type
 *             break;
 *         }
 *       } else {
 *         console.error("Task failed:", result.error);
 *       }
 *     }
 *   }
 * });
 * ```
 *
 * @description
 * Each task item in the array can include:
 * - `id`: The task identifier (must match one of the tasks in the union type)
 * - `payload`: Strongly-typed payload matching the task's input type
 * - `options`: Optional task-specific settings including:
 *   - `queue`: Specify a queue for the task
 *   - `concurrencyKey`: Control concurrent execution
 *   - `delay`: Delay before task execution
 *   - `ttl`: Time-to-live for the task
 *   - `tags`: Array of tags for the task
 *   - `maxAttempts`: Maximum retry attempts
 *   - `metadata`: Additional metadata
 *   - `maxDuration`: Maximum execution duration
 *
 * The function provides full type safety for:
 * - Task IDs
 * - Payload types
 * - Return value types
 * - Error handling
 */
async function batchTriggerAndWaitTasks(items, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return await tracer_js_1.tracer.startActiveSpan("batch.triggerByTaskAndWait()", async (span) => {
        const response = await apiClient.batchTriggerV2({
            items: await Promise.all(items.map(async (item) => {
                const taskMetadata = v3_1.taskCatalog.getTask(item.task.id);
                const parsedPayload = taskMetadata?.fns.parsePayload
                    ? await taskMetadata?.fns.parsePayload(item.payload)
                    : item.payload;
                const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
                return {
                    task: item.task.id,
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                        metadata: item.options?.metadata,
                        maxDuration: item.options?.maxDuration,
                    },
                };
            })),
            dependentAttempt: ctx.attempt.id,
        }, {}, requestOptions);
        span.setAttribute("batchId", response.id);
        span.setAttribute("runCount", response.runs.length);
        span.setAttribute("isCached", response.isCached);
        if (response.isCached) {
            console.warn(`Result is a cached response because the request was idempotent.`);
        }
        if (response.idempotencyKey) {
            span.setAttribute("idempotencyKey", response.idempotencyKey);
        }
        const result = await v3_1.runtime.waitForBatch({
            id: response.id,
            runs: response.runs.map((run) => run.id),
            ctx,
        });
        const runs = await handleBatchTaskRunExecutionResultV2(result.items);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
        },
    });
}
async function trigger_internal(name, id, payload, parsePayload, options, requestOptions) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
    const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
    const handle = await apiClient.triggerTask(id, {
        payload: payloadPacket.data,
        options: {
            queue: options?.queue,
            concurrencyKey: options?.concurrencyKey,
            test: v3_1.taskContext.ctx?.run.isTest,
            payloadType: payloadPacket.dataType,
            idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
            idempotencyKeyTTL: options?.idempotencyKeyTTL,
            delay: options?.delay,
            ttl: options?.ttl,
            tags: options?.tags,
            maxAttempts: options?.maxAttempts,
            parentAttempt: v3_1.taskContext.ctx?.attempt.id,
            metadata: options?.metadata,
            maxDuration: options?.maxDuration,
        },
    }, {
        spanParentAsLink: true,
    }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody: (body, span) => {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("runId", body.id);
                }
            }
        },
        ...requestOptions,
    });
    return handle;
}
async function batchTrigger_internal(name, taskIdentifier, items, options, parsePayload, requestOptions, queue) {
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const response = await apiClient.batchTriggerV2({
        items: await Promise.all(items.map(async (item) => {
            const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
            const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
            return {
                task: taskIdentifier,
                payload: payloadPacket.data,
                options: {
                    queue: item.options?.queue ?? queue,
                    concurrencyKey: item.options?.concurrencyKey,
                    test: v3_1.taskContext.ctx?.run.isTest,
                    payloadType: payloadPacket.dataType,
                    idempotencyKey: await (0, v3_1.makeIdempotencyKey)(item.options?.idempotencyKey),
                    idempotencyKeyTTL: item.options?.idempotencyKeyTTL,
                    delay: item.options?.delay,
                    ttl: item.options?.ttl,
                    tags: item.options?.tags,
                    maxAttempts: item.options?.maxAttempts,
                    parentAttempt: v3_1.taskContext.ctx?.attempt.id,
                    metadata: item.options?.metadata,
                    maxDuration: item.options?.maxDuration,
                },
            };
        })),
    }, {
        spanParentAsLink: true,
        idempotencyKey: await (0, v3_1.makeIdempotencyKey)(options?.idempotencyKey),
        idempotencyKeyTTL: options?.idempotencyKeyTTL,
    }, {
        name,
        tracer: tracer_js_1.tracer,
        icon: "trigger",
        onResponseBody(body, span) {
            if (body && typeof body === "object" && !Array.isArray(body)) {
                if ("id" in body && typeof body.id === "string") {
                    span.setAttribute("batchId", body.id);
                }
                if ("runs" in body && Array.isArray(body.runs)) {
                    span.setAttribute("runCount", body.runs.length);
                }
                if ("isCached" in body && typeof body.isCached === "boolean") {
                    if (body.isCached) {
                        console.warn(`Result is a cached response because the request was idempotent.`);
                    }
                    span.setAttribute("isCached", body.isCached);
                }
                if ("idempotencyKey" in body && typeof body.idempotencyKey === "string") {
                    span.setAttribute("idempotencyKey", body.idempotencyKey);
                }
            }
        },
        ...requestOptions,
    });
    const handle = {
        batchId: response.id,
        isCached: response.isCached,
        idempotencyKey: response.idempotencyKey,
        runs: response.runs,
        publicAccessToken: response.publicAccessToken,
    };
    return handle;
}
async function triggerAndWait_internal(name, id, payload, parsePayload, options, requestOptions) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("triggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    const parsedPayload = parsePayload ? await parsePayload(payload) : payload;
    const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.triggerTask(id, {
            payload: payloadPacket.data,
            options: {
                dependentAttempt: ctx.attempt.id,
                lockToVersion: v3_1.taskContext.worker?.version, // Lock to current version because we're waiting for it to finish
                queue: options?.queue,
                concurrencyKey: options?.concurrencyKey,
                test: v3_1.taskContext.ctx?.run.isTest,
                payloadType: payloadPacket.dataType,
                delay: options?.delay,
                ttl: options?.ttl,
                tags: options?.tags,
                maxAttempts: options?.maxAttempts,
                metadata: options?.metadata,
                maxDuration: options?.maxDuration,
            },
        }, {}, requestOptions);
        span.setAttribute("runId", response.id);
        const result = await v3_1.runtime.waitForTask({
            id: response.id,
            ctx,
        });
        return await handleTaskRunExecutionResult(result, id);
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function batchTriggerAndWait_internal(name, id, items, parsePayload, requestOptions, queue) {
    const ctx = v3_1.taskContext.ctx;
    if (!ctx) {
        throw new Error("batchTriggerAndWait can only be used from inside a task.run()");
    }
    const apiClient = v3_1.apiClientManager.clientOrThrow();
    return await tracer_js_1.tracer.startActiveSpan(name, async (span) => {
        const response = await apiClient.batchTriggerV2({
            items: await Promise.all(items.map(async (item) => {
                const parsedPayload = parsePayload ? await parsePayload(item.payload) : item.payload;
                const payloadPacket = await (0, v3_1.stringifyIO)(parsedPayload);
                return {
                    task: id,
                    payload: payloadPacket.data,
                    options: {
                        lockToVersion: v3_1.taskContext.worker?.version,
                        queue: item.options?.queue ?? queue,
                        concurrencyKey: item.options?.concurrencyKey,
                        test: v3_1.taskContext.ctx?.run.isTest,
                        payloadType: payloadPacket.dataType,
                        delay: item.options?.delay,
                        ttl: item.options?.ttl,
                        tags: item.options?.tags,
                        maxAttempts: item.options?.maxAttempts,
                        metadata: item.options?.metadata,
                        maxDuration: item.options?.maxDuration,
                    },
                };
            })),
            dependentAttempt: ctx.attempt.id,
        }, {}, requestOptions);
        span.setAttribute("batchId", response.id);
        span.setAttribute("runCount", response.runs.length);
        span.setAttribute("isCached", response.isCached);
        if (response.isCached) {
            console.warn(`Result is a cached response because the request was idempotent.`);
        }
        if (response.idempotencyKey) {
            span.setAttribute("idempotencyKey", response.idempotencyKey);
        }
        const result = await v3_1.runtime.waitForBatch({
            id: response.id,
            runs: response.runs.map((run) => run.id),
            ctx,
        });
        const runs = await handleBatchTaskRunExecutionResult(result.items, id);
        return {
            id: result.id,
            runs,
        };
    }, {
        kind: api_1.SpanKind.PRODUCER,
        attributes: {
            [v3_1.SemanticInternalAttributes.STYLE_ICON]: "trigger",
            ...(0, v3_1.accessoryAttributes)({
                items: [
                    {
                        text: id,
                        variant: "normal",
                    },
                ],
                style: "codepath",
            }),
        },
    });
}
async function handleBatchTaskRunExecutionResult(items, taskIdentifier) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, taskIdentifier);
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, taskIdentifier);
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleBatchTaskRunExecutionResultV2(items) {
    const someObjectStoreOutputs = items.some((item) => item.ok && item.outputType === "application/store");
    if (!someObjectStoreOutputs) {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? "unknown");
        }));
        return results;
    }
    return await tracer_js_1.tracer.startActiveSpan("store.downloadPayloads", async (span) => {
        const results = await Promise.all(items.map(async (item) => {
            return await handleTaskRunExecutionResult(item, item.taskIdentifier ?? "unknown");
        }));
        return results;
    }, {
        kind: api_1.SpanKind.INTERNAL,
        [v3_1.SemanticInternalAttributes.STYLE_ICON]: "cloud-download",
    });
}
async function handleTaskRunExecutionResult(execution, taskIdentifier) {
    if (execution.ok) {
        const outputPacket = { data: execution.output, dataType: execution.outputType };
        const importedPacket = await (0, v3_1.conditionallyImportPacket)(outputPacket, tracer_js_1.tracer);
        return {
            ok: true,
            id: execution.id,
            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),
            output: await (0, v3_1.parsePacket)(importedPacket),
        };
    }
    else {
        return {
            ok: false,
            id: execution.id,
            taskIdentifier: (execution.taskIdentifier ?? taskIdentifier),
            error: (0, v3_1.createErrorTaskError)(execution.error),
        };
    }
}
//# sourceMappingURL=shared.js.map